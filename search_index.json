[
["read-count-analysis.html", "4 Read count analysis 4.1 QC 4.2 Differential expression analysis", " 4 Read count analysis In this session, we walk through a gene-level RNA-seq differential expression analysis, as well as a differential exon usage analysis, using Bioconductor packages. Bioconductor has many packages supporting analysis of high-throughput sequence data, including RNA-seq. The packages which we will use in this tutorial include core packages maintained by the Bioconductor core team for importing and processing raw sequencing data and loading gene annotations. We will also use contributed packages for statistical analysis and visualization of sequencing data. 4.0.1 Data from Taito First we nead to transfer the $WRKDIR/DONOTREMOVE/day7/RNAseq_exercise/readCount directory from Taito to local computer. We can do it by login to sui.csc.fi or winscp. First create a directory GMB-203 in your local computer and copy the readCount directory in this folder. Also download Resource for exercise file to GMB-203 directory to define the experiment. Now open Rstudio and set working directory from “Session &gt; Set Working Directory &gt; Choose Directory” to GMB-203 4.0.2 Reading the metadata ## The first column is the sample name, the second column is the file name ## of the count files generated by htseq-count, and the remaining columns ## are sample metadata which will be stored in colData sampleMetaData &lt;- read.csv(&quot;sample_description.csv&quot;,header = TRUE) 4.0.3 Summarizing an RNA-seq experiment as a count matrix Count-based statistical methods such as DESeq2 (Love, Huber, and Anders 2014), edgeR (M. D. Robinson, McCarthy, and Smyth 2009), limma with the voom method (Law et al. 2014), DSS (H. Wu, Wang, and Wu 2013), EBSeq (Leng et al. 2013), BaySeq (Hardcastle and Kelly 2010) and DEXSeq (Anders, Reyes, and Huber 2012) expect input data as obtained, e.g., from RNA-seq or another high-throughput sequencing experiment in the form of a matrix of integer values, or “counts”. The value in the i-th row and the j-th column of the matrix tells how many reads (or fragments, for paired-end RNA-seq) have been assigned to feature i in sample j. For RNA-seq, a feature is typically a gene, a transcript or an exon. The fact that the values in the matrix are counts of sequencing reads (in the case of single-end sequencing) or fragments (for paired-end sequencing) is important for the count-based statistical models, e.g. DESeq2 or edgeR, as only the counts allow assessing the measurement precision correctly. It is important to never provide counts that have been normalized for sequencing depth/library size to these packages, as the statistical model is most powerful when applied to counts, and is designed to account for library size differences internally. 4.0.4 Installation First we will install Bioconductor and DESeq2 packages. if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) { install.packages(&quot;BiocManager&quot;,repos = &quot;http://cran.us.r-project.org&quot;) } if (!requireNamespace(&quot;DESeq2&quot;, quietly = TRUE)) { BiocManager::install(&quot;DESeq2&quot;, version = &quot;3.8&quot;) } 4.0.5 htseq-count htseq-count outputs a text file for each sample, containing the observed read count for each gene. It is worth noticing that the last five rows in these text files do not correspond to genes, but summarize the number of reads that were not assigned to genes for various reasons. We do not want to include these lines in the count matrix. It is of course possible to manually read the text files into R, remove the lines not corresponding to genes and merging the count vectors for all the samples into one count matrix. However, the DESeq2 package contains a function for constructing a DESeqDataSet directly from the output of htseq-count, and we will illustrate the use of it here (a more thorough description of the DESeqDataSet class is given below, for now it is enough to know that it is an example of a class where one can store all the information associated with an RNA-seq experiment). We need to provide the function with a sample table, where the first column is the sample name and the second is the name of the corresponding output file from htseq-count. Additional columns can be specified as well, and will be stored in the DESeqDataSet object. In this example we have already made the sample table sampleMetaData. suppressPackageStartupMessages(require(DESeq2)) ddsHTSeq &lt;- DESeqDataSetFromHTSeqCount(sampleTable = sampleMetaData, directory = &quot;readCount/&quot;, design= ~ pair+condition) ddsHTSeq ## class: DESeqDataSet ## dim: 55536 6 ## metadata(1): version ## assays(1): counts ## rownames(55536): ENSMUSG00000000001 ENSMUSG00000000003 ... ## ENSMUSG00000118392 ENSMUSG00000118393 ## rowData names(0): ## colnames(6): Derm5Ctrl Derm5Fgf20 ... Derm7Ctrl Derm7Fgf20 ## colData names(2): pair condition 4.1 QC We have seen in fastqc reports the presence of dual peaks in Per Sequence GC Content and high GC rich reads. We will measure the median expression of each gene and its corresponding “gc percentage”. ### Obtaining log transformed count values and calculating median of each gene. rlogMat&lt;-as.data.frame(assay(rlog(ddsHTSeq))) rlogMat$median &lt;- apply(rlogMat,1,median) if (!requireNamespace(&quot;xml2&quot;, quietly = TRUE)) { install.packages(&quot;xml2&quot;,repos = &quot;http://cran.us.r-project.org&quot;) } suppressPackageStartupMessages(require(xml2)) if (!requireNamespace(&quot;biomaRt&quot;, quietly = TRUE)) { BiocManager::install(&quot;biomaRt&quot;) } ### Use biomart to download gene information from Ensembl suppressPackageStartupMessages(require(biomaRt)) ensMart&lt;-useMart(&quot;ensembl&quot; ) ## ensDataSet &lt;- listDatasets(ensMart) ## mouse_id &lt;- grep(&quot;mouse&quot;,ensDataSet$description,ignore.case = TRUE) ## ensDataSet[mouse_id,] ensembl_ms_mart &lt;- useMart(biomart=&quot;ensembl&quot;, dataset=&quot;mmusculus_gene_ensembl&quot;) ### Which attributes of genes do we want to download ## grep(&quot;GC&quot;,listAttributes(ensembl_ms_mart)$description,ignore.case = TRUE) ## listAttributes(ensembl_ms_mart)[26,] gene_attributes&lt;- c(&quot;ensembl_gene_id&quot;, &quot;external_gene_name&quot;, &quot;gene_biotype&quot;, &quot;percentage_gene_gc_content&quot;) suppressMessages( gene_attribute_data &lt;- getBM(attributes=gene_attributes, values= rownames(rlogMat), ensembl_ms_mart, filters = &quot;ensembl_gene_id&quot;) ) rlogMat$ensembl_gene_id &lt;- rownames(rlogMat) rlogMat_biotype_gc &lt;- merge(rlogMat,gene_attribute_data,by=&quot;ensembl_gene_id&quot;) head(rlogMat_biotype_gc) ## ensembl_gene_id Derm5Ctrl Derm5Fgf20 Derm6Ctrl Derm6Fgf20 ## 1 ENSMUSG00000000001 8.8928811 9.0182708 8.9856921 8.9079000 ## 2 ENSMUSG00000000003 -1.9783942 -1.9790228 -1.9670873 -1.9779642 ## 3 ENSMUSG00000000028 6.6267082 6.5661234 6.6003497 6.5930273 ## 4 ENSMUSG00000000031 15.0212527 15.0295129 15.3359286 15.3490297 ## 5 ENSMUSG00000000037 5.4163466 5.4281514 5.3731305 5.3902636 ## 6 ENSMUSG00000000049 0.1983104 0.1703471 0.1968345 0.2003579 ## Derm7Ctrl Derm7Fgf20 median external_gene_name gene_biotype ## 1 8.8537671 8.8102337 8.9003905 Gnai3 protein_coding ## 2 -1.9787843 -1.9793395 -1.9785893 Pbsn protein_coding ## 3 6.4265227 6.4071196 6.5795754 Cdc45 protein_coding ## 4 15.0666101 15.3122778 15.1894439 H19 lincRNA ## 5 5.2159912 5.1540986 5.3816970 Scml2 protein_coding ## 6 0.2461662 0.1939255 0.1975725 Apoh protein_coding ## percentage_gene_gc_content ## 1 41.65 ## 2 38.23 ## 3 46.23 ## 4 55.83 ## 5 37.89 ## 6 43.83 4.1.0.1 Gene Biotype Plot median expression of different gene biotype. Are there any highly expressed rRNA ? suppressPackageStartupMessages(require(ggplot2)) give.n &lt;- function(x){ return(c(y = 24, label = length(x))) } ggplot(rlogMat_biotype_gc,aes(y=median,x=gene_biotype))+ geom_boxplot(aes(fill=gene_biotype))+ stat_summary(fun.data = give.n, geom = &quot;text&quot;)+ ylim(-5,25)+theme_bw()+ theme(legend.position=&quot;none&quot;,axis.text.x = element_text(angle = 90, hjust = 1)) Which are the highly expressed genes? rlogMat_biotype_gc[ rlogMat_biotype_gc$median&gt;15, c(&quot;external_gene_name&quot;, &quot;gene_biotype&quot; , &quot;median&quot;,&quot;percentage_gene_gc_content&quot;,&quot;ensembl_gene_id&quot;)] ## external_gene_name gene_biotype median percentage_gene_gc_content ## 4 H19 lincRNA 15.18944 55.83 ## 17918 mt-Rnr1 Mt_rRNA 16.25223 35.81 ## 17920 mt-Rnr2 Mt_rRNA 18.87056 35.40 ## 18329 Rn7sk misc_RNA 18.73874 58.01 ## ensembl_gene_id ## 4 ENSMUSG00000000031 ## 17918 ENSMUSG00000064337 ## 17920 ENSMUSG00000064339 ## 18329 ENSMUSG00000065037 There are Mitochondrial ribosomal RNA (Mt_rRNA) which are higly expressed but they are not gc rich. 4.1.1 Expression 4.1.1.1 Actual Count values Log transformed values suppress the actual expression levels. Let us redo the above analysis on count values. countData&lt;-as.data.frame(counts(ddsHTSeq)) countData$median &lt;- apply(countData,1,median) countData$ensembl_gene_id &lt;- rownames(countData) countData_biotype &lt;- merge(countData,gene_attribute_data,by=&quot;ensembl_gene_id&quot;) ggplot(countData_biotype, aes(x=percentage_gene_gc_content,y=median))+ geom_point()+xlim(25,75) ## Warning: Removed 80 rows containing missing values (geom_point). countData_biotype[ countData_biotype$median&gt;10000, c(&quot;external_gene_name&quot;, &quot;gene_biotype&quot;, &quot;median&quot;,&quot;percentage_gene_gc_content&quot;,&quot;ensembl_gene_id&quot;)] ## external_gene_name gene_biotype median ## 4 H19 lincRNA 36479.0 ## 7388 Actb protein_coding 13993.5 ## 10830 Eef1a1 protein_coding 11296.0 ## 17918 mt-Rnr1 Mt_rRNA 74793.0 ## 17920 mt-Rnr2 Mt_rRNA 484446.0 ## 18329 Rn7sk misc_RNA 427119.0 ## 21035 Gm10800 protein_coding 10444.5 ## 36463 Gm26917 lincRNA 18214.0 ## percentage_gene_gc_content ensembl_gene_id ## 4 55.83 ENSMUSG00000000031 ## 7388 54.56 ENSMUSG00000029580 ## 10830 46.87 ENSMUSG00000037742 ## 17918 35.81 ENSMUSG00000064337 ## 17920 35.40 ENSMUSG00000064339 ## 18329 58.01 ENSMUSG00000065037 ## 21035 35.63 ENSMUSG00000075014 ## 36463 69.12 ENSMUSG00000097971 There are two genes which have expressed a lot with with compared to other genes. 4.1.2 Visual Exploration Distance of DERMIS samples: A useful first step in an RNA-Seq analysis is often to assess overall similarity between samples: Which samples are similar to each other, which are different? Does this fit to the expectation from the experiment’s design? We use the R function dist to calculate the Euclidean distance between samples. To avoid that the distance measure is dominated by a few highly variable genes, and have a roughly equal contribution from all genes, we use it on the rlog-transformed data: ## Filtering out low expressed genes dermis &lt;- ddsHTSeq[ rowSums(counts(ddsHTSeq)) &gt; 1, ] dermis ## class: DESeqDataSet ## dim: 33113 6 ## metadata(1): version ## assays(1): counts ## rownames(33113): ENSMUSG00000000001 ENSMUSG00000000028 ... ## ENSMUSG00000118392 ENSMUSG00000118393 ## rowData names(0): ## colnames(6): Derm5Ctrl Derm5Fgf20 ... Derm7Ctrl Derm7Fgf20 ## colData names(2): pair condition rld &lt;- rlog(dermis) sampleDists &lt;- dist(t(assay(rld))) sampleDists ## Derm5Ctrl Derm5Fgf20 Derm6Ctrl Derm6Fgf20 Derm7Ctrl ## Derm5Fgf20 16.65626 ## Derm6Ctrl 20.51888 21.08852 ## Derm6Fgf20 21.52504 20.75272 21.89650 ## Derm7Ctrl 18.61694 21.67180 23.18757 21.64976 ## Derm7Fgf20 22.46988 23.01826 24.57369 21.08195 20.79349 Note the use of the function t to transpose the data matrix. We need this because dist calculates distances between data rows and our samples constitute the columns. We visualize the distances in a heatmap, using the function pheatmap from the pheatmap package. In order to plot the sample distance matrix with the rows/columns arranged by those distances in the matrix, we manually provide the sampleDists to the clustering_distance argument of the pheatmap function. Otherwise the pheatmap function would assume that the matrix contains the data values themselves, and would calculate distances between the rows/columns of the distance matrix, which is not desired. if (!requireNamespace(&quot;RColorBrewer&quot;, quietly = TRUE)) { install.packages(&quot;RColorBrewer&quot;,repos = &quot;http://cran.us.r-project.org&quot;) } suppressPackageStartupMessages(require(RColorBrewer)) if (!requireNamespace(&quot;pheatmap&quot;, quietly = TRUE)) { install.packages(&quot;pheatmap&quot;,repos = &quot;http://cran.us.r-project.org&quot;) } suppressPackageStartupMessages(library(&quot;pheatmap&quot;)) sampleDistMatrix &lt;- as.matrix(sampleDists) rownames(sampleDistMatrix) &lt;- rld$condition colnames(sampleDistMatrix) &lt;- colnames(dermis[,1:6]) colors &lt;- colorRampPalette( rev(brewer.pal(9, &quot;Blues&quot;)) )(255) pheatmap(sampleDistMatrix, clustering_distance_rows=sampleDists, clustering_distance_cols=sampleDists, col=colors) 4.1.2.1 PCA plot Another way to visualize sample-to-sample distances is a principal-components analysis (PCA). In this ordination method, the data points (i.e., here, the samples) are projected onto the 2D plane such that they spread out in the two directions which explain most of the differences in the data. The x-axis is the direction (or principal component) which separates the data points the most. The amount of the total variance which is contained in the direction is printed in the axis label. pcaData &lt;- plotPCA(rld, intgroup = c(&quot;condition&quot;,&quot;pair&quot;),returnData=TRUE) ggplot(pcaData, aes(PC1, PC2, text=name,group=pair)) + geom_point(size=3,aes(color=condition)) ## Reformat the plot percentVar &lt;- round(100 * attr(pcaData, &quot;percentVar&quot;)) p&lt;-ggplot(pcaData, aes(PC1, PC2, text=name,group=pair)) + geom_point(size=3,aes(color=condition)) + geom_line()+ xlab(paste0(&quot;PC1: &quot;,percentVar[1],&quot;% variance&quot;)) + ylab(paste0(&quot;PC2: &quot;,percentVar[2],&quot;% variance&quot;)) + coord_fixed()+ggtitle(&quot;Dermis &quot;) p Try this for inteactive plot if (!requireNamespace(&quot;plotly&quot;, quietly = TRUE)) { install.packages(&quot;plotly&quot;,repos = &quot;http://cran.us.r-project.org&quot;) } suppressPackageStartupMessages(require(plotly)) ggplotly(p) Mouse over the plot to see sample information. 4.2 Differential expression analysis It will be convenient to make sure that Ctrl is the first level in the dex factor, so that the default log2 fold changes are calculated as Control over Fgf20. The function relevel achieves this: dermis$condition &lt;- relevel(dermis$condition,&quot;Ctrl&quot;) ### Running DESeq data_DESeq &lt;- DESeq(dermis) ### Building the result table p_adjusted &lt;- 0.1 res &lt;- results(data_DESeq,alpha = p_adjusted,contrast = c(&quot;condition&quot;,&quot;Ctrl&quot;,&quot;Fgf20&quot;)) res ## log2 fold change (MLE): condition Ctrl vs Fgf20 ## Wald test p-value: condition Ctrl vs Fgf20 ## DataFrame with 33113 rows and 6 columns ## baseMean log2FoldChange lfcSE stat ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## ENSMUSG00000000001 482.589582 -0.001968488 0.1699237 -0.01158455 ## ENSMUSG00000000028 93.288303 0.054137927 0.2823991 0.19170712 ## ENSMUSG00000000031 37589.374754 -0.116978404 0.1315833 -0.88900665 ## ENSMUSG00000000037 40.625507 0.033563369 0.4054707 0.08277631 ## ENSMUSG00000000049 1.161685 1.373759532 2.2951400 0.59855152 ## ... ... ... ... ... ## ENSMUSG00000118389 0.6226259 -1.22182460 3.308730 -0.36927297 ## ENSMUSG00000118390 1.3496536 -0.56401881 2.224458 -0.25355338 ## ENSMUSG00000118391 1.1403282 -0.31144511 2.152180 -0.14471144 ## ENSMUSG00000118392 0.3499147 0.09311308 4.070224 0.02287665 ## ENSMUSG00000118393 0.3350958 -1.64537988 4.039865 -0.40728582 ## pvalue padj ## &lt;numeric&gt; &lt;numeric&gt; ## ENSMUSG00000000001 0.9907571 0.99987 ## ENSMUSG00000000028 0.8479716 0.99987 ## ENSMUSG00000000031 0.3739995 0.99987 ## ENSMUSG00000000037 0.9340294 NA ## ENSMUSG00000000049 0.5494720 NA ## ... ... ... ## ENSMUSG00000118389 0.7119243 NA ## ENSMUSG00000118390 0.7998406 NA ## ENSMUSG00000118391 0.8849387 NA ## ENSMUSG00000118392 0.9817487 NA ## ENSMUSG00000118393 0.6837981 NA As res is a DataFrame object, it carries metadata with information on the meaning of the columns: mcols(res, use.names=TRUE) ## DataFrame with 6 rows and 2 columns ## type ## &lt;character&gt; ## baseMean intermediate ## log2FoldChange results ## lfcSE results ## stat results ## pvalue results ## padj results ## description ## &lt;character&gt; ## baseMean mean of normalized counts for all samples ## log2FoldChange log2 fold change (MLE): condition Ctrl vs Fgf20 ## lfcSE standard error: condition Ctrl vs Fgf20 ## stat Wald statistic: condition Ctrl vs Fgf20 ## pvalue Wald test p-value: condition Ctrl vs Fgf20 ## padj BH adjusted p-values The first column, baseMean, is a just the average of the normalized count values, dividing by size factors, taken over all samples. The remaining four columns refer to a specific contrast, namely the comparison of the `Ctrl level over the Fgf20 level for the factor variable condition. See the help page for results (by typing ?results) for information on how to obtain other contrasts. The column log2FoldChange is the effect size estimate. It tells us how much the gene’s expression seems to have changed due to treatment with Fgf20 in comparison to controlled samples. This value is reported on a logarithmic scale to base 2: for example, a log2 fold change of 1.5 means that the gene’s expression is increased by a multiplicative factor of 21.5 or approximately 2.82. Of course, this estimate has an uncertainty associated with it, which is available in the column lfcSE, the standard error estimate for the log2 fold change estimate. We can also express the uncertainty of a particular effect size estimate as the result of a statistical test. The purpose of a test for differential expression is to test whether the data provides sufficient evidence to conclude that this value is really different from zero. DESeq2 performs for each gene a hypothesis test to see whether evidence is sufficient to decide against the null hypothesis that there is no effect of the treatment on the gene and that the observed difference between treatment and control was merely caused by experimental variability (i.e., the type of variability that you can just as well expect between different samples in the same treatment group). As usual in statistics, the result of this test is reported as a p value, and it is found in the column pvalue. (Remember that a p value indicates the probability that a fold change as strong as the observed one, or even stronger, would be seen under the situation described by the null hypothesis.) We can also summarize the results with the following line of code, which reports some additional information, which will be covered in later sections. summary(res) ## ## out of 33113 with nonzero total read count ## adjusted p-value &lt; 0.1 ## LFC &gt; 0 (up) : 3, 0.0091% ## LFC &lt; 0 (down) : 10, 0.03% ## outliers [1] : 0, 0% ## low counts [2] : 28889, 87% ## (mean count &lt; 88) ## [1] see &#39;cooksCutoff&#39; argument of ?results ## [2] see &#39;independentFiltering&#39; argument of ?results Note that there are many genes with differential expression due to treatment at the FDR level of 10%. However, there are two ways to be more strict about which set of genes are considered significant: lower the false discovery rate threshold (the threshold on padj in the results table) raise the log2 fold change threshold from 0 using the lfcThreshold argument of results. See the DESeq2 vignette for a demonstration of the use of this argument. If we lower the false discovery rate threshold, we should also tell this value to results(), so that the function will use an alternative threshold for the optimal independent filtering step: We subset the results table to these genes and then sort it by the log2 fold change . resSig &lt;- subset(res, padj &lt; p_adjusted) resSig &lt;- as.data.frame(resSig) ### Annotated the genes with previously downloaded data resSig$ensembl_gene_id &lt;- rownames(resSig) resSig_dermis_annotated &lt;- merge(resSig,gene_attribute_data,by=&quot;ensembl_gene_id&quot;) resSig_dermis_annotated &lt;- resSig_dermis_annotated[ order( -abs(resSig_dermis_annotated$log2FoldChange )),] 4.2.0.1 List of differentially expressed genes Rounding of the long decimal values. resSig_dermis_annotated[,c(-1,-8,-9)] &lt;-round(resSig_dermis_annotated[,c(-1,-8,-9)],4) ## DT::datatable(resSig_dermis_annotated[,c(1:3,6:9)],rownames = FALSE) resSig_dermis_annotated[,c(1:3,6:9)] ## ensembl_gene_id baseMean log2FoldChange pvalue padj ## 4 ENSMUSG00000024427 90.4842 -1.3337 0e+00 0.0173 ## 9 ENSMUSG00000030730 99.2619 -1.2306 1e-04 0.0377 ## 8 ENSMUSG00000027832 205.0323 1.2235 0e+00 0.0094 ## 5 ENSMUSG00000026241 106.4503 -1.2060 2e-04 0.0768 ## 3 ENSMUSG00000013089 132.5444 -1.2059 0e+00 0.0094 ## 12 ENSMUSG00000055435 171.5179 0.9440 1e-04 0.0377 ## 6 ENSMUSG00000026414 266.0920 -0.8826 2e-04 0.0768 ## 7 ENSMUSG00000026418 460.4309 -0.8751 0e+00 0.0103 ## 11 ENSMUSG00000046743 367.4537 0.7494 2e-04 0.0768 ## 2 ENSMUSG00000004891 765.4014 -0.7329 0e+00 0.0100 ## 1 ENSMUSG00000001473 440.6578 -0.6963 2e-04 0.0847 ## 10 ENSMUSG00000035783 802.9684 -0.5875 3e-04 0.0981 ## 13 ENSMUSG00000068699 625.1402 -0.5854 2e-04 0.0768 ## external_gene_name gene_biotype ## 4 Spry4 protein_coding ## 9 Atp2a1 protein_coding ## 8 Ptx3 protein_coding ## 5 Nppc protein_coding ## 3 Etv5 protein_coding ## 12 Maf protein_coding ## 6 Tnnt2 protein_coding ## 7 Tnni1 protein_coding ## 11 Fat4 protein_coding ## 2 Nes protein_coding ## 1 Tubb6 protein_coding ## 10 Acta2 protein_coding ## 13 Flnc protein_coding 4.2.1 Diagnostic plots A quick way to visualize the counts for a particular gene is to use the plotCounts function, which takes as arguments the DESeqDataSet, a gene name, and the group over which to plot the counts. topGene &lt;- rownames(res)[which.min(res$padj)] plotCounts(ddsHTSeq, gene=topGene, intgroup=c(&quot;condition&quot;)) The finishing part of this tutorial has been made following resource “Lab: End-to-end RNA-Seq workflow, Mike Love, Simon Anders, Wolfgang Huber” from bioconductor The above plot is not complete , there are other efficient ways to visualize . 4.2.1.1 DIY : Practice There is a new workflow by Michael I. Love, the developer of DESeq2. It has much more detailed explanations and diagonistic plots. Students are highly encouraged to go through this new workflow "]
]
