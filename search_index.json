[
["index.html", "Pipeline:4-RNA-seq and a minimal RNA-seq cook book Preface Structure of the book Acknowledgement", " Pipeline:4-RNA-seq and a minimal RNA-seq cook book Rishi Das Roy, Postdoctoral Fellow, Evo-Devo lab, University of Helsinki 2019-05-23 Preface The high throughput RNA-sequencing technology has been widely used and has advanced our understanding of RNA biology. The process of RNA-sequencing can be divided in two parts; 1) Generating the data from biological sample and 2) Computational data analysis. This book is about the second part which is usually done with a subset of many related software, refered as pipeline. For ease of biologist, there are many predefined and I have been analyzing RNA-seq data from 2014 using different. This book is an attempt to describe how to use the pipeline 4-RNA-seq and it is also a collection of the study materials which has been used in RNA-seq section of the course Advanced course in genomics and gene regulation 2019 by me. Structure of the book Chapter 1 and 2 explains the step wchich are executed from a unix terminal. Chapter 3 describes the final data analysis step which requires R and can be performed in any OS. Chapter 4 explains 4-RNA-seq pipleline which to execute chapter 1 and 2 commands in easier and efficient ways. Therefore chapter 1 to 3 is must for beginner and chapter 4 is for who have slurm environment and looking for a pipeline to execute RNA-seq data. Chapter 1: Quality Control Description of quality assessment, filtering ribosomal RNA and bad reads of fastq files with fastqc, multiqc, sortmerna and trimmomatic. Chapter 2: Alignment and count Alighnment of reads and count values from fastq and bam files using toll like star and htseq-count. Chapter 3: Read count analysis Differential expression analysis with R package DESeq2. Chapter 4: Pipeline:4-RNA-seq A step by step instruction for 4-RNA-seq pipeline execution. Acknowledgement Most of the study material are motivated from Rna-seq data analysis, Workshop II 1-3.11.2016. This could not be possible without the encouragement and permission from the istructor/author of the workshop. I like to thank * Nicolas DelHomme, Umeå University, Sweden * Bastian Schiffthaler, Umeå University, Sweden * Charlotte Soneson, Friedrich Miescher Institute for Biomedical Research * Petri Törönen, University of Helsinki for reviewing this book. The online version of this book is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],
["quality-control.html", "1 Quality control 1.1 Getting your share of the data 1.2 Workflow 1.3 Step 1. QA of raw reads 1.4 Step 2. Filtering rRNA 1.5 Step 3. Quality trimming and adapter removal", " 1 Quality control 1.1 Getting your share of the data The data used in this RNA-seq practice session are taken from published artcile (Biggs et. al. 2018). In this study, E13.5 mouse dermis (skin) was cut into two halves along the midline and one half was incubated in recombinant FGF20 protein and the other with protein vehicle. The objective was to identify up- and down-regulated genes through RNA-sequencing to reveal FGF20 signalling target genes. The cDNA libraries were prepared with TruSeq Stranded Total RNA kit with RiboZero (Illumina, San Diego, CA) ribosomal RNA eliminator kit, and single ends of samples were sequenced with NextSeq500 (Illumina, San Diego, CA). Open putty and login to server. Run following commands one by one. 1.1.0.1 First we will copy the fastq files generated by the sequencing unit. cd $WRKDIR cd DONOTREMOVE mkdir practice cd practice # copy raw fastq files cp /wrk/dasroy/DONOTREMOVE/GMB-203_rnaSeq/RNAseq_exercise.tar.gz ./ ## Extract the data tar -xvf RNAseq_exercise.tar.gz cd RNAseq_exercise/ ls -lrth rawReads/* # [Remember: FASTQ or FQ file formats are same] 1.2 Workflow Quality Assessment (QA) of raw reads using FastQC rRNA filtering using SortMeRna QA of filtered reads using MultiQC Quality trimming and adapter removal using Trimmomatic QA using FastQC Trimmed reads alignment using STAR QA with MultiQC Read count summarization using HTSeq htseq-count QA with MultiQC Report compilation with MultiQC Expression Analysis Step 2 and 3 can be done in any order. 1.3 Step 1. QA of raw reads The first pre-processing step is to assess the quality of the raw data received from the sequencing facility. This data is commonly delivered in FASTQ format ( file extension fastq or fq). Upon receiving the RNA-Seq FASTQ files from the sequencing facility, it is essential that some initial QC assessments be performed. Most importantly, one should check the overall sequence quality, the GC percentage distribution ( the proportion of guanine and cytosine bp across the reads) and the presence / absence of overrepresented sequences. FastQC has become a de-facto standard for performing this task http://www.bioinformatics.babraham.ac.uk/projects/fastqc/. A FastQC command line example is as follows: # First, make an output directory called &quot;qa&quot; (to collect all quality assessment reports) and a sub-directory of that called &quot;rawReads&quot; mkdir -p qa/rawReads_fastqc # First we load biokit module to access FastQC. module load biokit fastqc --help # Sample command to execute on a single file fastqc -o qa/rawReads_fastqc rawReads/Derm5Ctrl_run032119.fastq.gz # What are the output files. ls -lrth qa/rawReads/ The output of FastQC is a zip archive and an HTML document, which is sub-divided into sections describing the specific metrics that were analyzed. Login to sui.csc.fi and view any single report and go through the following categories. 1.3.1 FastQC on rest of the fastq files There are so many fastq files to process. However FastQC can run a number of files in parallel (see the -t option). fastqc -o qa/raw -t 16 raw/*.fastq.gz But let us run through by submitting as SLURM job. [ SLURM is a popular job scheduling system, another example ] Copy following text to a file fastqc_parallel.sh with nano editor. #!/bin/bash -l #SBATCH -J fastqc #SBATCH --constraint=&quot;snb|hsw&quot; #SBATCH -o fastqc_out_%j.txt #SBATCH -e fastqc_err_%j.txt #SBATCH -p serial #SBATCH -n 1 #SBATCH --cpus-per-task=6 ## *Number of fastq files* #SBATCH -t 00:50:00 #SBATCH --mem-per-cpu=2000 #SBATCH --mail-type=END module load biokit ## mkdir -p qa/rawReads fastqc -o qa/rawReads_fastqc -t $SLURM_CPUS_PER_TASK rawReads/*.fastq.gz Submit this job with following command sbatch fastqc_parallel.sh ## --mail-user your@email.com [using email is optional] Check status of job watch &quot;squeue -u $USER&quot; To exit “Watch” press Ctrl+C The metrics are explained in the slides. Check the out and error files fastqc_out_*.txt and fastqc_err_*.txt . These are the files which will contain any execution errors. 1.3.2 Summerize Finally, also run multiqc to summarize all data in one file. First we need to install multiqc which is not available in taito.csc.fi . Executes the following commands only once # Execute this command only once in your account module load biopython-env pip install --upgrade pip pip install multiqc pip install numpy --upgrade ## Check the installation and manual multiqc -h Now summarize all fastqc reports from qa/rawReads directory to a single html file. module load biopython-env multiqc -o qa/ -n rawReads qa/rawReads_fastqc # unload unnecessary module module unload biopython-env Now open the file qa/rawReads.html in the browser 1.4 Step 2. Filtering rRNA Typically, wet-lab protocols to extract mRNA include a step to deplete the sample of rRNA or to enrich it for poly-adenylated transcripts (rRNA is not poly-adenylated). Common approaches to achieve this are to use commercial kits or poly-dT beads, respectively. No approach will be fully sensitive and, as a result, some rRNA carryover is to be expected. This is not a problem per se as long as the remaining proportion accounts for a low percentage of the reads (commonly between 0.1 and 3%). Larger proportions will have an effect on the usable number of reads obtained from the samples, as fewer sequence reads would originate from expressed mRNAs. This is not to be overlooked as these rRNAs will produce valid alignments (in all reference genomes and for most de novo assembled transcriptomes and genomes) and hence other metrics (such as the alignment rate) will fail to identify such a bias. To control for the rRNA quantity in our sample FastQ files, we use SortMeRna, a tool originally developed to identify rRNA in metagenomics analyses (Kopylova, Noé, and Touzet 2012). The tool accepts FASTQ files (SE (single ended) or PE (paired ended)) as input and includes a set of reference libraries containing the most common rRNAs (5,5.8,16, 18, 23 and 26-28S). One of the sources of rRNA sequnces in fasta format is available here. # Store rRna filtered reads in &quot;sortMeRna&quot; directory mkdir sortMeRna module load qiime/1.9.1 sortmerna -h At first it is important to index once the reference libraries ( provided in fasta format) with following command. BUT do not execute it now as it is a time and memory consuming process. ## Example command to index reference library indexdb_rna --ref path_to_reference_file.fasta,path_to_indexed_file.idx ## Example command to filter out rRNA reads sortmerna --ref path_to_reference_file.fasta,path_to_indexed_file.idx \\ --reads input.fastq \\ --aligned rRNA_reads.fastq \\ --other non_rRna_reads.fastq \\ --sam --SQ --log -v --fastx -a 4 # Number of cpus Later you can try to index it yourself. Here we will use pre-indexed reference libraries (combined in a single fasta file all_rfam_arc_bac_5_16_18_23_28s.fasta ). Copy following text to a file sortmerna_script.sh with nano editor. #!/bin/bash -l #SBATCH -J sortmerna #SBATCH --constraint=&quot;snb|hsw&quot; #SBATCH -o sortmerna_out_%j.txt #SBATCH -e sortmerna_err_%j.txt #SBATCH -p serial #SBATCH -n 1 #SBATCH --cpus-per-task=4 #SBATCH -t 01:00:00 #SBATCH --mem-per-cpu=2000 #SBATCH --mail-type=END # First uncompress reads: zcat rawReads/Derm5Ctrl_run032119.fastq.gz &gt; rawReads/Derm5Ctrl_run032119.fastq module load qiime/1.9.1 # Run sortmerna sortmerna --ref /wrk/dasroy/DONOTREMOVE/GMB-203_rnaSeq/sortmerna_rRNA_database/all_rfam_arc_bac_5_16_18_23_28s.fasta,/wrk/dasroy/DONOTREMOVE/GMB-203_rnaSeq/sortmerna_rRNA_database/all_rfam_arc_bac_5_16_18_23_28s.idx \\ --reads rawReads/Derm5Ctrl_run032119.fastq \\ --aligned sortMeRna/rRna_Derm5Ctrl_run032119 \\ --other sortMeRna/non_rRna_Derm5Ctrl_run032119 \\ --sam --SQ --log -v --fastx -a $SLURM_CPUS_PER_TASK # Compress the files gzip sortMeRna/non_rRna_Derm5Ctrl_run032119.fastq The batch job could be launched with command: sbatch sortmerna_script.sh The quantity of found rRNAs are given in the last line of log files # What are the out put files ls -lrth sortMeRna # reads/sam files correspond to rRna could be deleted, we only need them for when there are high % of rRNA rm sortMeRna/rRna_Derm5Ctrl_run032119.fastq sortMeRna/rRna_Derm5Ctrl_run032119.sam # What is the %rRNA in one of the sample files? less sortMeRna/rRna_Derm5Ctrl_run032119.log # unload unnecessary module module unload qiime/1.9.1 The above script should be used for each fastq file individually by editing every time. However to save time we will copy the rest of the files. cp /wrk/dasroy/DONOTREMOVE/GMB-203_rnaSeq/sortMeRna/* sortMeRna/ # These log files should also exist in qa directory, hence make a shortut link of &quot;sortMeRna&quot; there ln -s $WRKDIR/DONOTREMOVE/practice/RNAseq_exercise/sortMeRna/ qa/sortMeRna # Summarize the result with after processing all the fastq files with sortmerna module load biopython-env multiqc -o qa/ -n sortMeRna qa/sortMeRna module unload biopython-env 1.5 Step 3. Quality trimming and adapter removal It is a fact that on Illumina sequencers, the quality of a base pair is linked to its position in the read, bases in the later cycles of the sequencing process have a lower average quality than the earliest cycles (as was observed in the QC report above). This effect depends on the sequencing facility and on the chemistry used and it is only recently that sequencing aligners have integrated methods to correct for this - and not all alignment software does so. A common approach to increase the mapping rate of reads is to trim (remove) low quality bases from the 3’ end until the quality reaches a user-selected Phred-quality threshold. A threshold of 20 is widely accepted as it corresponds to a base call error of 1 in a 100, which is approximately the inherent technical error rate of the Illumina sequencing platform. An additional issue encountered with Illumina sequencing is the presence of partial adapter sequences within sequenced reads. This arises when the sample fragment size has a large variance and fragments shorter than the sequencer read-length are sequenced. As the resulting reads may contain a significant part of the adapter - a bp sequence of artificial origin - earlier generation alignment software ( those that do not use Maximum Exact Matching and require global alignment of an entire read) may not be able to map such reads. Being able to identify the adapter-like sequences at the end of the read and clip/trim them - a process termed adapter removal - may consequently significantly increase the aligned read proportion. There are numerous tools available to perform either or both of these tasks (quality trimming and adapter removal). Here, we exemplify using Trimmomatic (Bolger, Lohse, and Usadel 2014), a tool that does both. The selection of trimming steps and their associated parameters are supplied on the trimmomatic command line. The current trimming steps are: ILLUMINACLIP: Cut adapter and other illumina-specific sequences from the read. SLIDINGWINDOW: Perform a sliding window trimming, cutting once the average quality within the window falls below a threshold. LEADING: Cut bases off the start of a read, if below a threshold quality TRAILING: Cut bases off the end of a read, if below a threshold quality CROP: Cut the read to a specified length HEADCROP: Cut the specified number of bases from the start of the read MINLEN: Drop the read if it is below a specified length TOPHRED33: Convert quality scores to Phred-33 TOPHRED64: Convert quality scores to Phred-64 !!!WARNING!!! Note that by default Trimmomatic tries to use all the computing cores of the server where it is launched. In Taito this approach is not feasible and you should always use command line option -threads to limit the number of cores to be used. Note that the -threads option should be given immediately after the mode selection (SE or PE). A sample trimmomatic command for taito-shell ( character: “\\” indicates that the command line continues to the next row) : # Not to execute trimmomatic SE -threads 4 -phred33 input.fq.gz output.fq.gz \\ ILLUMINACLIP:/appl/bio/trimmomatic/adapters/TruSeq3-SE.fa:2:30:1 \\ LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:36 This will perform the following: Remove adapters (ILLUMINACLIP:TruSeq3-PE.fa:2:30:1) Remove leading low quality or N bases (below quality 3) (LEADING:3) Remove trailing low quality or N bases (below quality 3) (TRAILING:3) Scan the read with a 4-base wide sliding window, cutting when the average quality per base drops below 15 (SLIDINGWINDOW:4:15) Drop reads below the 36 bases long (MINLEN:36) # make directory for trimmomatic outputs mkdir -p trimmomatic Here in the class we will use slurm scripts to use trimmomatic , also check taito documentation. Copy below lines to a file trimmomatic_script.sh with nano editor. This script will perform as a batch job reserving 4 cores, 12 hours and 4 GB of memory: #!/bin/bash #SBATCH -J trimmomatic #SBATCH -N 1 #SBATCH -p serial #SBATCH -t 01:00:00 #SBATCH --mem=4000 #SBATCH -o trimmomatic_out_%j.txt #SBATCH -e trimmomatic_err_%j.txt #SBATCH --cpus-per-task=8 trimmomatic SE -phred33 -threads $SLURM_CPUS_PER_TASK \\ sortMeRna/non_rRna_Derm5Ctrl_run032119.fastq.gz \\ trimmomatic/trimmed_non_rRna_Derm5Ctrl_run032119.fastq.gz \\ ILLUMINACLIP:/appl/bio/trimmomatic/adapters/TruSeq3-SE.fa:2:30:1 \\ LEADING:35 The batch job could be launched with command: sbatch trimmomatic_script.sh Now we can copy the rest of the files and run MultiQC. cp /wrk/dasroy/DONOTREMOVE/GMB-203_rnaSeq/trimmed_reads/* trimmomatic/ 1.5.1 Trimmed data FastQC A final FastQC run is performed to ensure that the previous rRNA filtering, quality trimming and/or adapter removal steps successfully conserved high quality reads without being too stringent and without introducing any newly apparent technical biases. Redo the FastQC on the Trimmomatic files you have generated. mkdir -p qa/trimmomatic_fastqc ## Make another slurm script similar to fastqc_parallel.sh by replacing &quot;rawReads&quot; with &quot;trimmomatic&quot; sed &#39;s/rawReads/trimmomatic/g&#39; fastqc_parallel.sh &gt; trimo_fastqc_parallel.sh ## inspect the difference diff fastqc_parallel.sh trimo_fastqc_parallel.sh Now execute it sbatch trimo_fastqc_parallel.sh Check status of job watch “squeue -u $USER” 1.5.2 Final filtering report module load biopython-env multiqc -o qa/ -n trimmomatic qa/trimmomatic_fastqc # unload unnecessary module module unload biopython-env "],
["alignment-and-count.html", "2 Alignment and count 2.1 Step 4. Alignment of reads 2.2 Step 5. Read count 2.3 Step 6. Final report", " 2 Alignment and count cd $WRKDIR cd DONOTREMOVE/day7/ ### How much data we have generated till now du -h RNAseq_exercise # Why rawRead is taking so much disk space ls -lh RNAseq_exercise/rawReads/ ## May be we can delete some unnecessary files cd RNAseq_exercise 2.1 Step 4. Alignment of reads Once the raw read quality has been assessed and determined to be sufficient, or the data has been filtered and trimmed to acceptable standards, the reads can be aligned to a reference. This process is an extremely active field of research and novel aligners are frequently published. There is, sadly, no “silver bullet” and the choice of aligners will be dependent on the reference to be used (genome or transcriptome), the data type (short vs. longer reads) and the available computational power, among other factors. Most recent aligners use either BWT (Burrows M 1994) (Burrows-Wheeler transformation) or MEM (Khan et al. 2009) (Maximum Exact Matches) to perform alignment. Older generation alignment algorithms relied on a spliced-seed approach (Heng Li and Homer 2010). The numerous implementations of these different strategies all come with a myriad of options that may significantly affect the alignment outcome. Selecting the most accurate aligner and determining the optimal parameter set for a project can often represent a small project in itself. At the time of writing this guide there was no guideline available as to which aligner is most appropriate for a given situation (read length, type of reference, etc.). Hence, in the following, we exemplify using aligners that we have incorporated in our processing pipeline based on internal benchmarking for our most common experimental setup: mouse/drosophila transcriptome, Illumina HiSeq 2500, 76bp SE sequencing. The aligner of choice varies based on the type of reference available for the project: For genome based alignment of RNA-Seq data we use STAR, a MEM based aligner - it actually uses MMP (maximum mappable prefix, a variation of MEM). 2.1.1 Alignment to the genome Here in this class, the STAR programm will be used for mapping. This programm is available by default which means no need to load any module. 2.1.1.1 Indexing the genome NOTE: The command line below is shown for exemplary purposes, NOT to be executed :-) First, the genome needs to be indexed. This is performed using the following command: STAR --runMode genomeGenerate --genomeDir GENOME/Indices --genomeFastaFiles \\ GENOME/FASTA/genome.fa --runThreadN 8 --sjdbOverhang 75 \\ --sjdbGTFfile GENOME/GTF/genome.gtf where the genomeDir parameter specifies the output directory for the index, genomeFastaFiles specifies the genome FASTA file path and sjdbGTFfile the file path of the gene annotation file, which can typically be retrieved from EnsEMBL (in gtf format) or UCSC (in gff3 format, to be converted in gtf format). We also provide an additional option that would need to be edited depending on your sequencing read length (sjdbOverhang 75); we selected 75 as our longuest reads are 76 bp long - see the STAR manual for the rationale behind this. For indexing the genome we need the “genome” (fasta) and “gene annotation” (GTF) files from public repositories first. Let us check from the “2.2 Advanced options.” of STAR manuals. We will use Ensembl FTP site Now we will download the rference genome and annotation files. # Create directory to store this reference files. mkdir mouse_genome_release-96 ## Copy the link of gtf file and download wget -P mouse_genome_release-96/ ftp://ftp.ensembl.org/pub/release-96/gtf/mus_musculus/Mus_musculus.GRCm38.96.gtf.gz # Unzip the file gunzip mouse_genome_release-96/Mus_musculus.GRCm38.96.gtf.gz ls mouse_genome_release-96/ ### Now similarly download and unzip the reference genome using the above commands ## After downloading these files we need their absolute paths find $PWD/mouse_genome_release-96/* STAR takes lots of memory and disk space to index the genome. It may take long time also. Copy the following code to star_index.sh #!/bin/bash -l # author: dasroy #SBATCH -J StarIndex #SBATCH --constraint=&quot;snb|hsw&quot; #SBATCH -o StarIndex_out_%j.txt #SBATCH -e StarIndex_err_%j.txt #SBATCH -p hugemem #SBATCH -n 1 #SBATCH --cpus-per-task=8 #SBATCH -t 12:00:00 #SBATCH --mem=32000 ## 32GB memory genomeGtf=&quot;/wrk/student041/day7_rishi/RNAseq_exercise/mouse_genome_release-96/Mus_musculus.GRCm38.96.gtf&quot; if [ ! -f &quot;$genomeGtf&quot; ] then echo &quot;gtf not found&quot; fi genomeFasta=&quot;/wrk/student041/day7_rishi/RNAseq_exercise/mouse_genome_release-96/Mus_musculus.GRCm38.dna.primary_assembly.fa&quot; if [ ! -f &quot;$genomeFasta&quot; ] then echo &quot;genome not found&quot; fi mkdir GENOME_Indices STAR --runMode genomeGenerate --genomeDir GENOME_Indices \\ --genomeFastaFiles $genomeFasta \\ --sjdbGTFfile $genomeGtf \\ --runThreadN $SLURM_CPUS_PER_TASK --sjdbOverhang 65 Submit the job with following coomand sbatch star_index.sh 2.1.2 Now align the reads Once the genome index is built, we can align our sample reads to it. This is achieved as follows: du -h GENOME_Indices ## Directory for alignment results mkdir starAlign ## Not to Execute STAR --genomeDir GENOME_Indices \\ --readFilesIn input.fastq.gz --readFilesCommand zcat \\ --outFileNamePrefix starAlign/star_annotated_input.fastq.gz \\ --outSAMtype BAM SortedByCoordinate ## We need the absolute path of INdexed_Genome directory find $PWD/GENOME_Indices where there are a number of additional parameters: The parameter --outFileNamePrefix sets the path and prefix to where the results will be written. Our sample files are GZip compressed so we inform STAR how to read it (readFilesCommand zcat). The outSAMtype BAM SortedByCoordinate ensures that the final result is already converted to the “BAM” format and sorted by coordinate, saving a few additional steps doing this via samtools. As you can see, we provide many more arguments, which you can lookup in the STAR manual; STAR is highly configurable! Copy the following code to star_align.sh #!/bin/bash -l # author: dasroy #SBATCH -J Star_align #SBATCH --constraint=&quot;snb|hsw&quot; #SBATCH -o StarAlign_out_%j.txt #SBATCH -e StarAlign_err_%j.txt #SBATCH -p hugemem #SBATCH -n 1 #SBATCH --cpus-per-task=8 #SBATCH -t 12:00:00 #SBATCH --mem=32000 genome_indexed=&quot;/wrk/student041/day7_rishi/RNAseq_exercise/GENOME_Indices&quot; if [ ! -f &quot;$genome_indexed&quot; ] then echo &quot;genome indexed not found&quot; fi STAR --genomeDir $genome_indexed \\ --readFilesIn trimmomatic/trimmed_non_rRna_Derm5Ctrl_run032119.fastq.gz --readFilesCommand zcat \\ --outFileNamePrefix starAlign/star_annotated_trimmed_non_rRna_Derm5Ctrl_run032119.fastq \\ --outSAMtype BAM SortedByCoordinate --runThreadN $SLURM_CPUS_PER_TASK ### Now need to index the BAM files module load biokit samtools index starAlign/star_annotated_trimmed_non_rRna_Derm5Ctrl_run032119.fastqAligned.sortedByCoord.out.bam Submit the job with following coomand sbatch star_align.sh 2.1.3 Post-processing the alignment result files STAR returns a number of result files: a star_annotated_trimmed_non_rRna_Derm5Ctrl_run032119.fastqAligned.sortedByCoord.out.bam SAM file that contains the alignment in SAM format (Li et al, 2009). a number of star_annotated_trimmed_non_rRna_Derm5Ctrl_run032119.fastqLog.* log files a number of star_annotated_trimmed_non_rRna_Derm5Ctrl_run032119.fastqSJ.* files containing splice junction information. Among the log files, Log.final.out and SJ.out.tab are of particular interest. The first details the alignment rate, percentage of uniquely/multiple aligning reads, rate of mismatches, INDELs identified in the reads, etc. The second file describes, in a tabular format, all the EEJs identified by STAR and whether these exist in the provided gff3 file or if they are novel. 2.1.4 Visualization The BAM format is very efficient for computers to work with, but as a binary file format, it is unreadble to humans. However we can use tools like IGV to visualize the alignments. For that we also need to index the bam files, which is alraedy done in the previous slurm script. Example command samtools index input.bam Now copy the bam and bam.bai files using winscp to your local computer. And open in the IGV tool. Copy the rest of the pre-aligned data. cp /wrk/dasroy/DONOTREMOVE/GMB-203_rnaSeq/star_alignment/* starAlign/ 2.1.5 Quality check of alignment Again we will use MultiQC to generate the alignment report. module load biopython-env multiqc -o qa/ -n starAlignment starAlign # unload unnecessary module module unload biopython-env 2.2 Step 5. Read count This step varies depending on whether expression at the gene or the transcript level is required. In our case, we are interested in gene expression, as we would like to perform a differential gene expression study. One major caveat estimating gene expression using aligned RNA-Seq reads is that a single read, which originated from a single mRNA molecule, can be aligned to several features ( transcripts or genes) if those alignments are of equivalent quality. This happens as a result of gene duplication and the presence of repetitive or common domains, for example. To avoid this, it is best practice to adopt a conservative approach by collapsing all existing transcripts of a single gene locus into a “synthetic” transcript containing every exon of that gene. 2.2.1 Counting reads per feature The second step is to perform the intersection between the aligned position of reads (contained in the alignment BAM file) and the gene coordinates obtained in the previous step, to count the number of reads overlapping a gene. There are two primary caveats here: First the annotation collapsing process detailed above works on a gene-by-gene basis and hence is oblivious to the existence of genes that may overlap another gene encoded on the opposite strand. Second, aligners may return multiple mapping positions for a single read. A de-facto standard for counting is the htseq-count tool supplied as part of the HTSeq python library (Anders, Pyl, and Huber 2014). This associated webpage illustrates in greater detail the issues discussed above. We have to provide “htseq-count” whether the data is from a strand-specific assay or not. Which depends on different library protocol and a good source of that is available from chipster. 2.2.1.1 Not to run Example command for stranded data htseq-count -f bam -m union -s reverse -t exon -i gene_id input.bam input.gtf &gt; \\ output.txt We will store the output of htseq-count in readCount directory. mkdir readCount Copy-paste the following commands to htseq_count.sh to submit another slurm job. #!/bin/bash -l # author: dasroy #SBATCH -J htseq-counting #SBATCH --constraint=&quot;snb|hsw&quot; #SBATCH -o htseq_out_%j.txt #SBATCH -e htseq_err_%j.txt #SBATCH -p serial #SBATCH -n 1 #SBATCH --cpus-per-task=8 #SBATCH -t 01:00:00 #SBATCH --mem=4000 genomeGtf=&quot;/wrk/student041/day7_rishi/RNAseq_exercise/mouse_genome_release-96/Mus_musculus.GRCm38.96.gtf&quot; module load biokit htseq-count -s reverse -t exon -i gene_id \\ starAlign/star_annotated_trimmed_non_rRna_Derm5Ctrl_run032119.fastqAligned.sortedByCoord.out.bam $genomeGtf &gt; \\ readCount/htseq_star_annotated_trimmed_non_rRna_Derm5Ctrl_run032119.fastq.gz.txt Submit the job with following coomand sbatch htseq_count.sh Copy the rest of the data and check quality cp /wrk/dasroy/DONOTREMOVE/GMB-203_rnaSeq/star_count/* readCount/ # QC module load biopython-env multiqc -o qa/ -n htseqCount readCount # unload unnecessary module module unload biopython-env 2.3 Step 6. Final report Till now we have used MultiQC to generate the report corresponding to each tool separately by scanning individual folders. Previous MultiQC commands were : 2.3.0.1 Not to run 1. multiqc -o qa/ -n rawReads qa/rawReads_fastqc 2. multiqc -o qa/ -n sortMeRna qa/sortMeRna 3. multiqc -o qa/ -n trimmomatic qa/trimmomatic_fastqc 4. multiqc -o qa/ -n starAlignment starAlign 5. multiqc -o qa/ -n htseqCount readCount Let us try to combine them to a single report ## Delete the extra file in readCount directory rm readCount/htseq_star_annotated_trimmed_non_rRna_Derm5Ctrl_run032119.fastq.gz.txt module load biopython-env multiqc -o qa/ -n finalReport ./ # scanning the whole project directory There are solution to this in MultiQC manuals. Due to mismatch in filenames in different output directories( like sortMeRna, starAlign and others), there are too many rows instead of six rows in ‘General Statistics’ section of qa/finalReport.html. MultiQC is higly configurable and filenames can be fixed by configuring ‘multiqc_config.yaml’. See the documentation. Pay attention to extra_fn_clean_exts and extra_fn_clean_trim: Now we will try to configure ‘multiqc_config.yaml’ # Download the example config file wget https://raw.githubusercontent.com/ewels/MultiQC/master/test/config_example.yaml #rename it to mv config_example.yaml multiqc_config.yaml nano multiqc_config.yaml "],
["read-count-analysis.html", "3 Read count analysis 3.1 QC 3.2 Differential expression analysis", " 3 Read count analysis In this session, we walk through a gene-level RNA-seq differential expression analysis, as well as a differential exon usage analysis, using Bioconductor packages. Bioconductor has many packages supporting analysis of high-throughput sequence data, including RNA-seq. The packages which we will use in this tutorial include core packages maintained by the Bioconductor core team for importing and processing raw sequencing data and loading gene annotations. We will also use contributed packages for statistical analysis and visualization of sequencing data. 3.0.1 Data from Taito First we nead to transfer the $WRKDIR/DONOTREMOVE/day7/RNAseq_exercise/readCount directory from Taito to local computer. We can do it by login to sui.csc.fi or winscp. First create a directory GMB-203 in your local computer and copy the readCount directory in this folder. Also download Resource for exercise file to GMB-203 directory to define the experiment. Now open Rstudio and set working directory from “Session &gt; Set Working Directory &gt; Choose Directory” to GMB-203 3.0.2 Reading the metadata ## The first column is the sample name, the second column is the file name ## of the count files generated by htseq-count, and the remaining columns ## are sample metadata which will be stored in colData sampleMetaData &lt;- read.csv(&quot;sample_description.csv&quot;,header = TRUE) 3.0.3 Summarizing an RNA-seq experiment as a count matrix Count-based statistical methods such as DESeq2 (Love, Huber, and Anders 2014), edgeR (M. D. Robinson, McCarthy, and Smyth 2009), limma with the voom method (Law et al. 2014), DSS (H. Wu, Wang, and Wu 2013), EBSeq (Leng et al. 2013), BaySeq (Hardcastle and Kelly 2010) and DEXSeq (Anders, Reyes, and Huber 2012) expect input data as obtained, e.g., from RNA-seq or another high-throughput sequencing experiment in the form of a matrix of integer values, or “counts”. The value in the i-th row and the j-th column of the matrix tells how many reads (or fragments, for paired-end RNA-seq) have been assigned to feature i in sample j. For RNA-seq, a feature is typically a gene, a transcript or an exon. The fact that the values in the matrix are counts of sequencing reads (in the case of single-end sequencing) or fragments (for paired-end sequencing) is important for the count-based statistical models, e.g. DESeq2 or edgeR, as only the counts allow assessing the measurement precision correctly. It is important to never provide counts that have been normalized for sequencing depth/library size to these packages, as the statistical model is most powerful when applied to counts, and is designed to account for library size differences internally. 3.0.4 Installation First we will install Bioconductor and DESeq2 packages. if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) { install.packages(&quot;BiocManager&quot;,repos = &quot;http://cran.us.r-project.org&quot;) } if (!requireNamespace(&quot;DESeq2&quot;, quietly = TRUE)) { BiocManager::install(&quot;DESeq2&quot;) } 3.0.5 htseq-count htseq-count outputs a text file for each sample, containing the observed read count for each gene. It is worth noticing that the last five rows in these text files do not correspond to genes, but summarize the number of reads that were not assigned to genes for various reasons. We do not want to include these lines in the count matrix. It is of course possible to manually read the text files into R, remove the lines not corresponding to genes and merging the count vectors for all the samples into one count matrix. However, the DESeq2 package contains a function for constructing a DESeqDataSet directly from the output of htseq-count, and we will illustrate the use of it here (a more thorough description of the DESeqDataSet class is given below, for now it is enough to know that it is an example of a class where one can store all the information associated with an RNA-seq experiment). We need to provide the function with a sample table, where the first column is the sample name and the second is the name of the corresponding output file from htseq-count. Additional columns can be specified as well, and will be stored in the DESeqDataSet object. In this example we have already made the sample table sampleMetaData. suppressPackageStartupMessages(require(DESeq2)) ddsHTSeq &lt;- DESeqDataSetFromHTSeqCount(sampleTable = sampleMetaData, directory = &quot;readCount/&quot;, design= ~ pair+condition) ddsHTSeq ## class: DESeqDataSet ## dim: 55536 6 ## metadata(1): version ## assays(1): counts ## rownames(55536): ENSMUSG00000000001 ENSMUSG00000000003 ... ## ENSMUSG00000118392 ENSMUSG00000118393 ## rowData names(0): ## colnames(6): Derm5Ctrl Derm5Fgf20 ... Derm7Ctrl Derm7Fgf20 ## colData names(2): pair condition 3.1 QC We have seen in fastqc reports the presence of dual peaks in Per Sequence GC Content and high GC rich reads. We will measure the median expression of each gene and its corresponding “gc percentage”. ### Obtaining log transformed count values and calculating median of each gene. rlogMat&lt;-as.data.frame(assay(rlog(ddsHTSeq))) rlogMat$median &lt;- apply(rlogMat,1,median) if (!requireNamespace(&quot;xml2&quot;, quietly = TRUE)) { install.packages(&quot;xml2&quot;,repos = &quot;http://cran.us.r-project.org&quot;) } suppressPackageStartupMessages(require(xml2)) if (!requireNamespace(&quot;biomaRt&quot;, quietly = TRUE)) { BiocManager::install(&quot;biomaRt&quot;) } ## Bioconductor version 3.8 (BiocManager 1.30.4), R 3.5.0 (2018-04-23) ## Installing package(s) &#39;biomaRt&#39; ## also installing the dependencies &#39;hms&#39;, &#39;progress&#39; ## Updating HTML index of packages in &#39;.Library&#39; ## Making &#39;packages.html&#39; ... done ## Update old packages: &#39;AnnotationDbi&#39;, &#39;assertthat&#39;, &#39;backports&#39;, &#39;BH&#39;, ## &#39;Biobase&#39;, &#39;BiocInstaller&#39;, &#39;bookdown&#39;, &#39;boot&#39;, &#39;Cairo&#39;, &#39;callr&#39;, ## &#39;caTools&#39;, &#39;class&#39;, &#39;cli&#39;, &#39;clipr&#39;, &#39;cluster&#39;, &#39;codetools&#39;, ## &#39;colorspace&#39;, &#39;commonmark&#39;, &#39;curl&#39;, &#39;data.table&#39;, &#39;devtools&#39;, &#39;digest&#39;, ## &#39;dplyr&#39;, &#39;evaluate&#39;, &#39;fansi&#39;, &#39;foreign&#39;, &#39;formatR&#39;, &#39;ggplot2&#39;, &#39;git2r&#39;, ## &#39;glue&#39;, &#39;GO.db&#39;, &#39;gtable&#39;, &#39;hexbin&#39;, &#39;highr&#39;, &#39;htmlwidgets&#39;, &#39;httpuv&#39;, ## &#39;httr&#39;, &#39;igraph&#39;, &#39;ini&#39;, &#39;irlba&#39;, &#39;jsonlite&#39;, &#39;knitr&#39;, &#39;later&#39;, ## &#39;lattice&#39;, &#39;lazyeval&#39;, &#39;markdown&#39;, &#39;MASS&#39;, &#39;Matrix&#39;, &#39;mgcv&#39;, &#39;mime&#39;, ## &#39;nlme&#39;, &#39;openssl&#39;, &#39;org.Hs.eg.db&#39;, &#39;org.Mm.eg.db&#39;, &#39;pcaMethods&#39;, ## &#39;pillar&#39;, &#39;pkgbuild&#39;, &#39;pkgload&#39;, &#39;plotly&#39;, &#39;purrr&#39;, &#39;R6&#39;, &#39;rcmdcheck&#39;, ## &#39;Rcpp&#39;, &#39;RcppArmadillo&#39;, &#39;rlang&#39;, &#39;rmarkdown&#39;, &#39;roxygen2&#39;, &#39;rpart&#39;, ## &#39;rstudioapi&#39;, &#39;Rtsne&#39;, &#39;sessioninfo&#39;, &#39;shiny&#39;, &#39;stringi&#39;, &#39;stringr&#39;, ## &#39;styler&#39;, &#39;survival&#39;, &#39;testthat&#39;, &#39;tibble&#39;, &#39;tidyr&#39;, &#39;tidyselect&#39;, ## &#39;tinytex&#39;, &#39;urltools&#39;, &#39;usethis&#39;, &#39;vioplot&#39;, &#39;xfun&#39;, &#39;xtable&#39;, &#39;yaml&#39; ### Use biomart to download gene information from Ensembl suppressPackageStartupMessages(require(biomaRt)) ensMart&lt;-useMart(&quot;ensembl&quot; ) ## ensDataSet &lt;- listDatasets(ensMart) ## mouse_id &lt;- grep(&quot;mouse&quot;,ensDataSet$description,ignore.case = TRUE) ## ensDataSet[mouse_id,] ensembl_ms_mart &lt;- useMart(biomart=&quot;ensembl&quot;, dataset=&quot;mmusculus_gene_ensembl&quot;) ### Which attributes of genes do we want to download ## grep(&quot;GC&quot;,listAttributes(ensembl_ms_mart)$description,ignore.case = TRUE) ## listAttributes(ensembl_ms_mart)[26,] gene_attributes&lt;- c(&quot;ensembl_gene_id&quot;, &quot;external_gene_name&quot;, &quot;gene_biotype&quot;, &quot;percentage_gene_gc_content&quot;) suppressMessages( gene_attribute_data &lt;- getBM(attributes=gene_attributes, values= rownames(rlogMat), ensembl_ms_mart, filters = &quot;ensembl_gene_id&quot;) ) rlogMat$ensembl_gene_id &lt;- rownames(rlogMat) rlogMat_biotype_gc &lt;- merge(rlogMat,gene_attribute_data,by=&quot;ensembl_gene_id&quot;) head(rlogMat_biotype_gc) ## ensembl_gene_id Derm5Ctrl Derm5Fgf20 Derm6Ctrl Derm6Fgf20 Derm7Ctrl ## 1 ENSMUSG00000000001 8.8928814 9.0182690 8.985691 8.9079000 8.8537681 ## 2 ENSMUSG00000000003 -1.9783943 -1.9790229 -1.967087 -1.9779643 -1.9787844 ## 3 ENSMUSG00000000028 6.6267080 6.5661234 6.600350 6.5930272 6.4265229 ## 4 ENSMUSG00000000031 15.0212564 15.0295163 15.335925 15.3490263 15.0666127 ## 5 ENSMUSG00000000037 5.4163475 5.4281523 5.373131 5.3902641 5.2159899 ## 6 ENSMUSG00000000049 0.1983099 0.1703455 0.196834 0.2003575 0.2461676 ## Derm7Fgf20 median external_gene_name gene_biotype ## 1 8.8102354 8.9003907 Gnai3 protein_coding ## 2 -1.9793396 -1.9785894 Pbsn protein_coding ## 3 6.4071199 6.5795753 Cdc45 protein_coding ## 4 15.3122752 15.1894439 H19 lincRNA ## 5 5.1540966 5.3816975 Scml2 protein_coding ## 6 0.1939248 0.1975719 Apoh protein_coding ## percentage_gene_gc_content ## 1 41.65 ## 2 38.23 ## 3 46.23 ## 4 55.83 ## 5 37.89 ## 6 43.83 3.1.0.1 Gene Biotype Plot median expression of different gene biotype. Are there any highly expressed rRNA ? suppressPackageStartupMessages(require(ggplot2)) give.n &lt;- function(x){ return(c(y = 24, label = length(x))) } ggplot(rlogMat_biotype_gc,aes(y=median,x=gene_biotype))+ geom_boxplot(aes(fill=gene_biotype))+ stat_summary(fun.data = give.n, geom = &quot;text&quot;)+ ylim(-5,25)+theme_bw()+ theme(legend.position=&quot;none&quot;,axis.text.x = element_text(angle = 90, hjust = 1)) Which are the highly expressed genes? rlogMat_biotype_gc[ rlogMat_biotype_gc$median&gt;15, c(&quot;external_gene_name&quot;, &quot;gene_biotype&quot; , &quot;median&quot;,&quot;percentage_gene_gc_content&quot;,&quot;ensembl_gene_id&quot;)] ## external_gene_name gene_biotype median percentage_gene_gc_content ## 4 H19 lincRNA 15.18944 55.83 ## 17918 mt-Rnr1 Mt_rRNA 16.25223 35.81 ## 17920 mt-Rnr2 Mt_rRNA 18.87056 35.40 ## 18329 Rn7sk misc_RNA 18.73874 58.01 ## ensembl_gene_id ## 4 ENSMUSG00000000031 ## 17918 ENSMUSG00000064337 ## 17920 ENSMUSG00000064339 ## 18329 ENSMUSG00000065037 There are Mitochondrial ribosomal RNA (Mt_rRNA) which are higly expressed but they are not gc rich. 3.1.1 Expression 3.1.1.1 Actual Count values Log transformed values suppress the actual expression levels. Let us redo the above analysis on count values. countData&lt;-as.data.frame(counts(ddsHTSeq)) countData$median &lt;- apply(countData,1,median) countData$ensembl_gene_id &lt;- rownames(countData) countData_biotype &lt;- merge(countData,gene_attribute_data,by=&quot;ensembl_gene_id&quot;) ggplot(countData_biotype, aes(x=percentage_gene_gc_content,y=median))+ geom_point()+xlim(25,75) ## Warning: Removed 80 rows containing missing values (geom_point). countData_biotype[ countData_biotype$median&gt;10000, c(&quot;external_gene_name&quot;, &quot;gene_biotype&quot;, &quot;median&quot;,&quot;percentage_gene_gc_content&quot;,&quot;ensembl_gene_id&quot;)] ## external_gene_name gene_biotype median ## 4 H19 lincRNA 36479.0 ## 7388 Actb protein_coding 13993.5 ## 10830 Eef1a1 protein_coding 11296.0 ## 17918 mt-Rnr1 Mt_rRNA 74793.0 ## 17920 mt-Rnr2 Mt_rRNA 484446.0 ## 18329 Rn7sk misc_RNA 427119.0 ## 21035 Gm10800 protein_coding 10444.5 ## 36463 Gm26917 lincRNA 18214.0 ## percentage_gene_gc_content ensembl_gene_id ## 4 55.83 ENSMUSG00000000031 ## 7388 54.56 ENSMUSG00000029580 ## 10830 46.87 ENSMUSG00000037742 ## 17918 35.81 ENSMUSG00000064337 ## 17920 35.40 ENSMUSG00000064339 ## 18329 58.01 ENSMUSG00000065037 ## 21035 35.63 ENSMUSG00000075014 ## 36463 69.12 ENSMUSG00000097971 There are two genes which have expressed a lot with with compared to other genes. 3.1.2 Visual Exploration Distance of DERMIS samples: A useful first step in an RNA-Seq analysis is often to assess overall similarity between samples: Which samples are similar to each other, which are different? Does this fit to the expectation from the experiment’s design? We use the R function dist to calculate the Euclidean distance between samples. To avoid that the distance measure is dominated by a few highly variable genes, and have a roughly equal contribution from all genes, we use it on the rlog-transformed data: ## Filtering out low expressed genes dermis &lt;- ddsHTSeq[ rowSums(counts(ddsHTSeq)) &gt; 1, ] dermis ## class: DESeqDataSet ## dim: 33113 6 ## metadata(1): version ## assays(1): counts ## rownames(33113): ENSMUSG00000000001 ENSMUSG00000000028 ... ## ENSMUSG00000118392 ENSMUSG00000118393 ## rowData names(0): ## colnames(6): Derm5Ctrl Derm5Fgf20 ... Derm7Ctrl Derm7Fgf20 ## colData names(2): pair condition rld &lt;- rlog(dermis) sampleDists &lt;- dist(t(assay(rld))) sampleDists ## Derm5Ctrl Derm5Fgf20 Derm6Ctrl Derm6Fgf20 Derm7Ctrl ## Derm5Fgf20 16.65617 ## Derm6Ctrl 20.51871 21.08833 ## Derm6Fgf20 21.52486 20.75254 21.89631 ## Derm7Ctrl 18.61681 21.67162 23.18736 21.64960 ## Derm7Fgf20 22.46966 23.01802 24.57344 21.08177 20.79332 Note the use of the function t to transpose the data matrix. We need this because dist calculates distances between data rows and our samples constitute the columns. We visualize the distances in a heatmap, using the function pheatmap from the pheatmap package. In order to plot the sample distance matrix with the rows/columns arranged by those distances in the matrix, we manually provide the sampleDists to the clustering_distance argument of the pheatmap function. Otherwise the pheatmap function would assume that the matrix contains the data values themselves, and would calculate distances between the rows/columns of the distance matrix, which is not desired. if (!requireNamespace(&quot;RColorBrewer&quot;, quietly = TRUE)) { install.packages(&quot;RColorBrewer&quot;,repos = &quot;http://cran.us.r-project.org&quot;) } suppressPackageStartupMessages(require(RColorBrewer)) if (!requireNamespace(&quot;pheatmap&quot;, quietly = TRUE)) { install.packages(&quot;pheatmap&quot;,repos = &quot;http://cran.us.r-project.org&quot;) } suppressPackageStartupMessages(library(&quot;pheatmap&quot;)) sampleDistMatrix &lt;- as.matrix(sampleDists) rownames(sampleDistMatrix) &lt;- rld$condition colnames(sampleDistMatrix) &lt;- colnames(dermis[,1:6]) colors &lt;- colorRampPalette( rev(brewer.pal(9, &quot;Blues&quot;)) )(255) pheatmap(sampleDistMatrix, clustering_distance_rows=sampleDists, clustering_distance_cols=sampleDists, col=colors) 3.1.2.1 PCA plot Another way to visualize sample-to-sample distances is a principal-components analysis (PCA). In this ordination method, the data points (i.e., here, the samples) are projected onto the 2D plane such that they spread out in the two directions which explain most of the differences in the data. The x-axis is the direction (or principal component) which separates the data points the most. The amount of the total variance which is contained in the direction is printed in the axis label. pcaData &lt;- plotPCA(rld, intgroup = c(&quot;condition&quot;,&quot;pair&quot;),returnData=TRUE) ggplot(pcaData, aes(PC1, PC2, text=name,group=pair)) + geom_point(size=3,aes(color=condition)) ## Reformat the plot percentVar &lt;- round(100 * attr(pcaData, &quot;percentVar&quot;)) p&lt;-ggplot(pcaData, aes(PC1, PC2, text=name,group=pair)) + geom_point(size=3,aes(color=condition)) + geom_line()+ xlab(paste0(&quot;PC1: &quot;,percentVar[1],&quot;% variance&quot;)) + ylab(paste0(&quot;PC2: &quot;,percentVar[2],&quot;% variance&quot;)) + coord_fixed()+ggtitle(&quot;Dermis &quot;) p Try this for inteactive plot if (!requireNamespace(&quot;plotly&quot;, quietly = TRUE)) { install.packages(&quot;plotly&quot;,repos = &quot;http://cran.us.r-project.org&quot;) } suppressPackageStartupMessages(require(plotly)) ggplotly(p) Mouse over the plot to see sample information. 3.2 Differential expression analysis It will be convenient to make sure that Ctrl is the first level in the dex factor, so that the default log2 fold changes are calculated as Control over Fgf20. The function relevel achieves this: dermis$condition &lt;- relevel(dermis$condition,&quot;Ctrl&quot;) ### Running DESeq data_DESeq &lt;- DESeq(dermis) ### Building the result table p_adjusted &lt;- 0.1 res &lt;- results(data_DESeq,alpha = p_adjusted,contrast = c(&quot;condition&quot;,&quot;Ctrl&quot;,&quot;Fgf20&quot;)) res ## log2 fold change (MLE): condition Ctrl vs Fgf20 ## Wald test p-value: condition Ctrl vs Fgf20 ## DataFrame with 33113 rows and 6 columns ## baseMean log2FoldChange ## &lt;numeric&gt; &lt;numeric&gt; ## ENSMUSG00000000001 482.589581951071 -0.00196846898573668 ## ENSMUSG00000000028 93.2883026483124 0.0541378880773732 ## ENSMUSG00000000031 37589.3747537343 -0.116978404552591 ## ENSMUSG00000000037 40.6255065570166 0.0335637483438453 ## ENSMUSG00000000049 1.16168525034731 1.37376747953866 ## ... ... ... ## ENSMUSG00000118389 0.622625890309737 -1.2218285808629 ## ENSMUSG00000118390 1.34965364036737 -0.564010979927982 ## ENSMUSG00000118391 1.14032818716345 -0.311443280164532 ## ENSMUSG00000118392 0.349914725382352 0.0931130751735958 ## ENSMUSG00000118393 0.335095765655296 -1.64537987766277 ## lfcSE stat pvalue ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## ENSMUSG00000000001 0.169927828508702 -0.0115841472406968 0.990757394481716 ## ENSMUSG00000000028 0.282414164366719 0.191696787584189 0.847979722458958 ## ENSMUSG00000000031 0.13158221918433 -0.889013768560319 0.373995680175779 ## ENSMUSG00000000037 0.40549504870913 0.0827722766299948 0.934032613507353 ## ENSMUSG00000000049 2.29527101906209 0.598520814374253 0.549492474810633 ## ... ... ... ... ## ENSMUSG00000118389 3.30896250238058 -0.369248240191259 0.711942701960871 ## ENSMUSG00000118390 2.22460115087907 -0.253533528787894 0.799855955085032 ## ENSMUSG00000118391 2.15229957334881 -0.144702570228154 0.884945709770831 ## ENSMUSG00000118392 4.07022403992349 0.0228766461649974 0.981748669180653 ## ENSMUSG00000118393 4.03986536923328 -0.407285819521022 0.683798076584825 ## padj ## &lt;numeric&gt; ## ENSMUSG00000000001 0.999869568398613 ## ENSMUSG00000000028 0.999869568398613 ## ENSMUSG00000000031 0.999869568398613 ## ENSMUSG00000000037 NA ## ENSMUSG00000000049 NA ## ... ... ## ENSMUSG00000118389 NA ## ENSMUSG00000118390 NA ## ENSMUSG00000118391 NA ## ENSMUSG00000118392 NA ## ENSMUSG00000118393 NA As res is a DataFrame object, it carries metadata with information on the meaning of the columns: mcols(res, use.names=TRUE) ## DataFrame with 6 rows and 2 columns ## type ## &lt;character&gt; ## baseMean intermediate ## log2FoldChange results ## lfcSE results ## stat results ## pvalue results ## padj results ## description ## &lt;character&gt; ## baseMean mean of normalized counts for all samples ## log2FoldChange log2 fold change (MLE): condition Ctrl vs Fgf20 ## lfcSE standard error: condition Ctrl vs Fgf20 ## stat Wald statistic: condition Ctrl vs Fgf20 ## pvalue Wald test p-value: condition Ctrl vs Fgf20 ## padj BH adjusted p-values The first column, baseMean, is a just the average of the normalized count values, dividing by size factors, taken over all samples. The remaining four columns refer to a specific contrast, namely the comparison of the `Ctrl level over the Fgf20 level for the factor variable condition. See the help page for results (by typing ?results) for information on how to obtain other contrasts. The column log2FoldChange is the effect size estimate. It tells us how much the gene’s expression seems to have changed due to treatment with Fgf20 in comparison to controlled samples. This value is reported on a logarithmic scale to base 2: for example, a log2 fold change of 1.5 means that the gene’s expression is increased by a multiplicative factor of 21.5 or approximately 2.82. Of course, this estimate has an uncertainty associated with it, which is available in the column lfcSE, the standard error estimate for the log2 fold change estimate. We can also express the uncertainty of a particular effect size estimate as the result of a statistical test. The purpose of a test for differential expression is to test whether the data provides sufficient evidence to conclude that this value is really different from zero. DESeq2 performs for each gene a hypothesis test to see whether evidence is sufficient to decide against the null hypothesis that there is no effect of the treatment on the gene and that the observed difference between treatment and control was merely caused by experimental variability (i.e., the type of variability that you can just as well expect between different samples in the same treatment group). As usual in statistics, the result of this test is reported as a p value, and it is found in the column pvalue. (Remember that a p value indicates the probability that a fold change as strong as the observed one, or even stronger, would be seen under the situation described by the null hypothesis.) We can also summarize the results with the following line of code, which reports some additional information, which will be covered in later sections. summary(res) ## ## out of 33113 with nonzero total read count ## adjusted p-value &lt; 0.1 ## LFC &gt; 0 (up) : 3, 0.0091% ## LFC &lt; 0 (down) : 10, 0.03% ## outliers [1] : 0, 0% ## low counts [2] : 28889, 87% ## (mean count &lt; 88) ## [1] see &#39;cooksCutoff&#39; argument of ?results ## [2] see &#39;independentFiltering&#39; argument of ?results Note that there are many genes with differential expression due to treatment at the FDR level of 10%. However, there are two ways to be more strict about which set of genes are considered significant: lower the false discovery rate threshold (the threshold on padj in the results table) raise the log2 fold change threshold from 0 using the lfcThreshold argument of results. See the DESeq2 vignette for a demonstration of the use of this argument. If we lower the false discovery rate threshold, we should also tell this value to results(), so that the function will use an alternative threshold for the optimal independent filtering step: We subset the results table to these genes and then sort it by the log2 fold change . resSig &lt;- subset(res, padj &lt; p_adjusted) resSig &lt;- as.data.frame(resSig) ### Annotated the genes with previously downloaded data resSig$ensembl_gene_id &lt;- rownames(resSig) resSig_dermis_annotated &lt;- merge(resSig,gene_attribute_data,by=&quot;ensembl_gene_id&quot;) resSig_dermis_annotated &lt;- resSig_dermis_annotated[ order( -abs(resSig_dermis_annotated$log2FoldChange )),] 3.2.0.1 List of differentially expressed genes Rounding of the long decimal values. resSig_dermis_annotated[,c(-1,-8,-9)] &lt;-round(resSig_dermis_annotated[,c(-1,-8,-9)],4) ## DT::datatable(resSig_dermis_annotated[,c(1:3,6:9)],rownames = FALSE) resSig_dermis_annotated[,c(1:3,6:9)] ## ensembl_gene_id baseMean log2FoldChange pvalue padj ## 4 ENSMUSG00000024427 90.4842 -1.3337 0e+00 0.0173 ## 9 ENSMUSG00000030730 99.2619 -1.2306 1e-04 0.0377 ## 8 ENSMUSG00000027832 205.0323 1.2235 0e+00 0.0094 ## 5 ENSMUSG00000026241 106.4503 -1.2060 2e-04 0.0768 ## 3 ENSMUSG00000013089 132.5444 -1.2059 0e+00 0.0094 ## 12 ENSMUSG00000055435 171.5179 0.9440 1e-04 0.0377 ## 6 ENSMUSG00000026414 266.0920 -0.8826 2e-04 0.0768 ## 7 ENSMUSG00000026418 460.4309 -0.8751 0e+00 0.0103 ## 11 ENSMUSG00000046743 367.4537 0.7494 2e-04 0.0768 ## 2 ENSMUSG00000004891 765.4014 -0.7329 0e+00 0.0100 ## 1 ENSMUSG00000001473 440.6578 -0.6963 2e-04 0.0847 ## 10 ENSMUSG00000035783 802.9684 -0.5875 3e-04 0.0981 ## 13 ENSMUSG00000068699 625.1402 -0.5854 2e-04 0.0768 ## external_gene_name gene_biotype ## 4 Spry4 protein_coding ## 9 Atp2a1 protein_coding ## 8 Ptx3 protein_coding ## 5 Nppc protein_coding ## 3 Etv5 protein_coding ## 12 Maf protein_coding ## 6 Tnnt2 protein_coding ## 7 Tnni1 protein_coding ## 11 Fat4 protein_coding ## 2 Nes protein_coding ## 1 Tubb6 protein_coding ## 10 Acta2 protein_coding ## 13 Flnc protein_coding 3.2.1 Diagnostic plots A quick way to visualize the counts for a particular gene is to use the plotCounts function, which takes as arguments the DESeqDataSet, a gene name, and the group over which to plot the counts. topGene &lt;- rownames(res)[which.min(res$padj)] plotCounts(ddsHTSeq, gene=topGene, intgroup=c(&quot;condition&quot;)) The finishing part of this tutorial has been made following resource “Lab: End-to-end RNA-Seq workflow, Mike Love, Simon Anders, Wolfgang Huber” from bioconductor The above plot is not complete , there are other efficient ways to visualize . 3.2.1.1 DIY : Practice There is a new workflow by Michael I. Love, the developer of DESeq2. It has much more detailed explanations and diagonistic plots. Students are highly encouraged to go through this new workflow "],
["pipeline-4-rna-seq.html", "4 Pipeline 4-RNA-seq 4.1 How to run 4.2 EXTRA", " 4 Pipeline 4-RNA-seq A slurm based schema for RNA-seq analysis to execute on linux clusters. The purpose of this project to develop a list of scripts whose input and output will be folders containing either fastq or bam files. This schema contains easily customizable bash scripts and directory structure. This pipeline and workflow is based on Taito.csc server batch scripts. The objective of this documentation is to make execution faster and reproducible as much as possible. The project folder will contain these folders before starting scripts : contains all scripts to run in taito server OUT : contains output files defined by #SBATCH -o in all scripts ERROR : contains error files defined in #SBATCH -e in all scripts commands : contains actual history of commands rawReads : should contain sequencing reads generated by the sequencing machine. This folder name could be anything. 4.0.1 Dependency Multiqc ( run almost after all the commands) { installation guide}. This has been already done in previous class. 4.0.2 Installation 4-RNA-seq is required to download for every new project. 4.0.2.1 Download For each experiment 4-RNA-seq pipeline needs to be downloaded separately. Let us download it to a directory named “day10” with following commands cd $WRKDIR cd DONOTREMOVE git clone https://github.com/vondoRishi/4-RNA-seq day10 ### Check what is in day10 tree -C day10 From now on day10 is the project space 4.0.2.2 Prepare the workspace Make a directory rawreads inside day10 and copy old fastq(.gz) files from day7 exercises to there. mkdir day10/rawReads cp day7/RNAseq_exercise/rawReads/*fastq.gz day10/rawReads 4.1 How to run 4.1.1 Download public resources 4.1.1.1 rRNA fasta files Download few fasta files from sortmerna website and combine them (this is just for demonstration). ## move to project directory cd day10 mkdir rRNAFasta wget -P rRNAFasta https://github.com/biocore/sortmerna/raw/master/rRNA_databases/silva-arc-16s-id95.fasta wget -P rRNAFasta https://github.com/biocore/sortmerna/raw/master/rRNA_databases/silva-arc-23s-id98.fasta ## Combine all rRNA fasta files in a single file cat rRNAFasta/silva-arc-* &gt; rRNAFasta/combined_rRNA.fasta ### Copy the path of combined_rRNA.fasta find $PWD/rRNAFasta/ ### reuse the mouse genome and gtf files downloaded earlier. Their paths are available at star_index.sh Before execution please define the project variables in the 4-rna-seq.config file. These values will be used by different scripts of this pipeline. Edit this file with nano ## There should not be any space around &quot;=&quot; project_name=&quot;test_name&quot; sequence_type=&quot;single&quot; ## single ## for paired-end need to change the scripts manually ### parameter used by HTSeq; is data strand specific ? stranded=&quot;yes&quot; ### yes|reverse|no ### sortmerna parameter sortMeRNA_ref=&quot;$WRKDIR/DONOTREMOVE/Mouse_genome/rRNA_operon/Mouse_ribosomal_operon.fasta&quot; ### STAR aligner parameter maxReadLength=10 ## this parameter should be set after finishing the QC ### parameter used by STAR and HTSeq genome_file=&quot;$WRKDIR/DONOTREMOVE/Mouse_genome/Mus_musculus_GRCm38.fa&quot; gene_annotation=&quot;$WRKDIR/DONOTREMOVE/Mouse_genome/Mus_musculus.GRCm38.79.gtf&quot; ### parameter used by TopHat / Cufflinks / Cuffdiff; library_type=&quot;fr-secondstrand&quot; ## fr-secondstrand|fr-firststrand|fr-unstranded 4.1.2 Step 1-3. QC and Filtering After running each ‘sbatch’ command always check the sizes of output files, zero file size is absolute mark of something went wrong. 4.1.2.1 Step 1. QA of raw reads Start QC ( quality checking) with Fastqc and Multiqc. In earlier class we have executed fastqc and multiqc separately. However the scripts/fastqc.sh executes both Fastqc and Multiqc internally. sbatch --mail-user ur_email_at_domain scripts/fastqc.sh rawReads ## Don&#39;t use &quot;rawReads/&quot; Input : any directory with fastq or fastq.gz files, here rawReads Output : Output generated in input directory, here rawReads/rawReads.html and other fastqc.html files 4.1.2.2 Step 2. Filtering rRNA sbatch --mail-user ur_email_at_domain scripts/sortmerna.sh rawReads sortMeRna Input: directory with fastq files Output: sortMeRna, the folder contains many different types of file. Fastq/fq files starting with non_Rna will be used in downstream analysis. Files with .log will be used by multiqc to summarize. The “rRna” fastq/fq and “.sam” files should be (re)moved from sortMeRna before next step. After (re)moving “rRna*.fq&quot; files, the rest of the .fq files could be compressed. sbatch --mail-user ur_email_at_domain scripts/compress_fastq.sh sortMeRna Input: directory with fastq files Output: same as input directory Now summarize the presence of rRNA. sbatch --mail-user ur_email_at_domain scripts/fastqc.sh sortMeRna 4.1.2.3 Step 3. Quality trimming and adapter removal Needs to edit scripts/trimmo.sh for additional paramenters of Trimmomatic program sbatch --mail-user ur_email_at_domain scripts/trimmo.sh sortMeRna trimmomatic Input : directory with fastq or fastq.gz files Output : directory with trimmed reads in fastq format sbatch --mail-user ur_email_at_domain scripts/fastqc.sh trimmomatic 4.1.3 Step 4. Alignment of reads This script will 1) index the genome in a folder star-genome_ann_Indices, 2) align the reads from individual samples 3) run multiqc. Confirm the parameters in file 4-rna-seq.config maxReadLength to maximum read length genome_file to path to reference genome gene_annotation path to gtf file sbatch --mail-user ur_email_at_domain scripts/star.sh trimmomatic starAlign Input: folder which contains the filtered reads; ex. good or sortMeRna Output: Directory with bam files and multiqc report. 4.1.4 Step 5. Read count Confirm the parameters in file 4-rna-seq.config stranded depending upon the library type gene_annotation path to gtf file sbatch --mail-user ur_email_at_domain scripts/star_htseq-count.sh starAlign star_count Input: Directory with bam files Output: Directory with count values, star_count/htseq_*txt and quality report at star_count.html 4.1.5 Final report Till now we have generated multiqc reports for every command or folder. Now to summarize all in one place execute. Edit multiqc multiqc_config.yaml file if require sbatch --mail-user ur_email_at_domain scripts/multiqc_slurm.sh 4.2 EXTRA 4.2.1 Alignment read viewer Need to sort (uncomment for tophat output bams) and index bam files. sbatch --mail-user ur_email_at_domain scripts/samtools_index.sh bam_directory 4.2.2 Compressing fastq files sbatch --mail-user ur_email_at_domain scripts/compress_fastq.sh fastq_Directory "]
]
