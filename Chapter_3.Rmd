# Read count analysis

In this session, we walk through a gene-level RNA-seq differential expression analysis, as well as a differential exon usage analysis, using Bioconductor packages. Bioconductor has many packages supporting analysis of high-throughput sequence data, including RNA-seq. The packages which we will use in this tutorial include core packages maintained by the Bioconductor core team for importing and processing raw sequencing data and loading gene annotations. We will also use contributed packages for statistical analysis and visualization of sequencing data. 

### Data from Taito

First we nead to transfer the `$WRKDIR/DONOTREMOVE/day7/RNAseq_exercise/readCount` directory from Taito to local computer. We can do it by login to sui.csc.fi or winscp. First create a directory `GMB-203` in your local computer and copy the `readCount` directory in this folder. Also download [`Resource for exercise`](https://moodle.helsinki.fi/mod/resource/view.php?id=1584905) file to `GMB-203` directory to define the experiment.  
Now open `Rstudio` and set working directory from "Session > Set Working Directory > Choose Directory" to `GMB-203` 

### Reading the metadata

```{r initialization,warning=FALSE,echo=TRUE,message=FALSE}
## The first column is the sample name, the second column is the file name 
## of the count files generated by htseq-count, and the remaining columns 
## are sample metadata which will be stored in colData

sampleMetaData <- read.csv("sample_description.csv",header = TRUE)
```

### Summarizing an RNA-seq experiment as a count matrix 
Count-based statistical methods such as DESeq2 (Love, Huber, and Anders 2014), edgeR (M. D. Robinson, McCarthy, and Smyth 2009), limma with the voom method (Law et al. 2014), DSS (H. Wu, Wang, and Wu 2013), EBSeq (Leng et al. 2013), BaySeq (Hardcastle and Kelly 2010) and DEXSeq (Anders, Reyes, and Huber 2012) expect input data as obtained, e.g., from RNA-seq or another high-throughput sequencing experiment in the form of a matrix of integer values, or "counts". The value in the i-th row and the j-th column of the matrix tells how many reads (or fragments, for paired-end RNA-seq) have been assigned to feature i in sample j. For RNA-seq, a feature is typically a gene, a transcript or an exon. 

The fact that the values in the matrix are counts of sequencing reads (in the case of single-end sequencing) or fragments (for paired-end sequencing) is important for the count-based statistical models, e.g. `DESeq2` or `edgeR`, as only the counts allow assessing the measurement precision correctly. It is important to **never provide counts** that have been normalized for sequencing depth/library size to these packages, as the statistical model is most powerful when applied to counts, and is designed to account for library size differences internally.

### Installation 

First we will install Bioconductor and DESeq2 packages.

```{r warning=FALSE,echo=TRUE,message=FALSE,eval=TRUE}
if (!requireNamespace("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager",repos = "http://cran.us.r-project.org")
}

if (!requireNamespace("DESeq2", quietly = TRUE)) {
    BiocManager::install("DESeq2")
}

```


### htseq-count

`htseq-count` outputs a text file for each sample, containing the observed read count for each gene. It is worth noticing that the last five rows in these text files do not correspond to genes, but summarize the number of reads that were not assigned to genes for various reasons. We do not want to include these lines in the count matrix.

It is of course possible to manually read the text files into R, remove the lines not corresponding to genes and merging the count vectors for all the samples into one count matrix. However, the `DESeq2` package contains a function for constructing a DESeqDataSet directly from the output of `htseq-count`, and we will illustrate the use of it here (a more thorough description of the DESeqDataSet class is given below, for now it is enough to know that it is an example of a class where one can store all the information associated with an RNA-seq experiment). We need to provide the function with a sample table, where the **first column** is the sample name and the **second** is the name of the corresponding output file from htseq-count. Additional columns can be specified as well, and will be stored in the DESeqDataSet object.

In this example we have already made the sample table **sampleMetaData**.

```{r DESeq2}
suppressPackageStartupMessages(require(DESeq2))
ddsHTSeq <- DESeqDataSetFromHTSeqCount(sampleTable = sampleMetaData, 
                                        directory = "readCount/",
                                       design= ~ pair+condition)

ddsHTSeq
```


## QC

We have seen in `fastqc` reports the presence of dual peaks in **Per Sequence GC Content** and high GC rich reads. We will measure the median expression of each gene and its corresponding "gc percentage".



```{r ensembl_qc,echo=TRUE,cache=TRUE}
### Obtaining log transformed count values and calculating median of each gene.
rlogMat<-as.data.frame(assay(rlog(ddsHTSeq)))
rlogMat$median <- apply(rlogMat,1,median)

if (!requireNamespace("xml2", quietly = TRUE)) {
    install.packages("xml2",repos = "http://cran.us.r-project.org")
}
suppressPackageStartupMessages(require(xml2))
if (!requireNamespace("biomaRt", quietly = TRUE)) {
    BiocManager::install("biomaRt")
}
  

### Use biomart to download gene information from Ensembl
suppressPackageStartupMessages(require(biomaRt))
ensMart<-useMart("ensembl" )

## ensDataSet <- listDatasets(ensMart)
## mouse_id <- grep("mouse",ensDataSet$description,ignore.case = TRUE)
## ensDataSet[mouse_id,]

ensembl_ms_mart <- useMart(biomart="ensembl", dataset="mmusculus_gene_ensembl")

### Which attributes of genes do we want to download

## grep("GC",listAttributes(ensembl_ms_mart)$description,ignore.case = TRUE)
## listAttributes(ensembl_ms_mart)[26,]

gene_attributes<- c("ensembl_gene_id",  "external_gene_name", 
                    "gene_biotype", "percentage_gene_gc_content")
suppressMessages(
  gene_attribute_data <- getBM(attributes=gene_attributes, 
                               values= rownames(rlogMat), 
                               ensembl_ms_mart, filters = "ensembl_gene_id") )

rlogMat$ensembl_gene_id <- rownames(rlogMat)
rlogMat_biotype_gc <- merge(rlogMat,gene_attribute_data,by="ensembl_gene_id")

head(rlogMat_biotype_gc)
```

#### Gene Biotype

Plot median expression of different gene biotype. Are there any highly expressed rRNA ?

```{r fig.height=5}
suppressPackageStartupMessages(require(ggplot2))
give.n <- function(x){
  return(c(y = 24, label = length(x),angle=90))
}

ggplot(rlogMat_biotype_gc,aes(y=median,x=gene_biotype))+
    geom_boxplot(aes(fill=gene_biotype))+
    stat_summary(fun.data = give.n, geom = "text")+
    ylim(-5,25)+theme_bw()+ 
  theme(legend.position="none",axis.text.x = element_text(angle = 90, hjust = 1))
```

Which are the highly expressed genes?

```{r }
rlogMat_biotype_gc[ rlogMat_biotype_gc$median>15,
                    c("external_gene_name", "gene_biotype" ,
                    "median","percentage_gene_gc_content","ensembl_gene_id")]
```

There are Mitochondrial ribosomal RNA (Mt_rRNA) which are higly expressed but they are not gc rich.  

### Expression

#### Actual Count values

Log transformed values suppress the actual expression levels. Let us redo the above analysis on count values.

```{r fig.height=5,warning=FALSE}
countData<-as.data.frame(counts(ddsHTSeq))
countData$median <- apply(countData,1,median)
countData$ensembl_gene_id <- rownames(countData)

countData_biotype <- merge(countData,gene_attribute_data,by="ensembl_gene_id")

ggplot(countData_biotype, aes(x=percentage_gene_gc_content,y=median))+
  geom_point()+xlim(25,75)

countData_biotype[ countData_biotype$median>10000,
                   c("external_gene_name", "gene_biotype",
                     "median","percentage_gene_gc_content","ensembl_gene_id")]
```

There are two genes which have expressed a lot with with compared to other genes.  


### Visual Exploration

**Distance of DERMIS samples**: A useful first step in an RNA-Seq analysis is often to assess overall similarity between samples: Which samples are similar to each other, which are different? Does this fit to the expectation from the experiment's design?

We use the R function dist to calculate the Euclidean distance between samples. To avoid that the distance measure is dominated by a few highly variable genes, and have a roughly equal contribution from all genes, we use it on the rlog-transformed data:

```{r }
## Filtering out low expressed genes
dermis <- ddsHTSeq[ rowSums(counts(ddsHTSeq)) > 1, ]
dermis

rld <- rlog(dermis)

sampleDists <- dist(t(assay(rld)))
sampleDists
```
Note the use of the function t to transpose the data matrix. We need this because dist calculates distances between data rows and our samples constitute the columns.

We visualize the distances in a heatmap, using the function pheatmap from the pheatmap package.

In order to plot the sample distance matrix with the rows/columns arranged by those distances in the matrix, we manually provide the `sampleDists` to the `clustering_distance` argument of the pheatmap function. Otherwise the pheatmap function would assume that the matrix contains the data values themselves, and would calculate distances between the rows/columns of the distance matrix, which is not desired.

```{r}
if (!requireNamespace("RColorBrewer", quietly = TRUE)) {
  install.packages("RColorBrewer",repos = "http://cran.us.r-project.org")
}
suppressPackageStartupMessages(require(RColorBrewer))

if (!requireNamespace("pheatmap", quietly = TRUE)) {
  install.packages("pheatmap",repos = "http://cran.us.r-project.org")
}
suppressPackageStartupMessages(library("pheatmap"))

sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- rld$condition
colnames(sampleDistMatrix) <- colnames(dermis[,1:6])
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)

```

#### PCA plot

Another way to visualize sample-to-sample distances is a principal-components analysis (PCA). In this ordination method, the data points (i.e., here, the samples) are projected onto the 2D plane such that they spread out in the two directions which explain most of the differences in the data. The x-axis is the direction (or principal component) which separates the data points the most. The amount of the total variance which is contained in the direction is printed in the axis label.

```{r}
pcaData <- plotPCA(rld, intgroup = c("condition","pair"),returnData=TRUE)
 
ggplot(pcaData, aes(PC1, PC2,  text=name,group=pair)) +
  geom_point(size=3,aes(color=condition))

## Reformat the plot
percentVar <- round(100 * attr(pcaData, "percentVar"))
p<-ggplot(pcaData, aes(PC1, PC2,  text=name,group=pair)) +
  geom_point(size=3,aes(color=condition)) + geom_line()+
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
  coord_fixed()+ggtitle("Dermis ")
p

```

Try this for inteactive plot

```{r eval=FALSE}
if (!requireNamespace("plotly", quietly = TRUE)) {
  install.packages("plotly",repos = "http://cran.us.r-project.org")
}
suppressPackageStartupMessages(require(plotly))
ggplotly(p) 
```

Mouse over the plot to see sample information.  
```{r warning=FALSE,echo=FALSE,message=FALSE}
## require(gridExtra)
## require(gplots)
## require(xlsx)
## require(vsn)
 
```




## Differential expression analysis

It will be convenient to make sure that `Ctrl` is the first level in the dex factor, so that the default log2 fold changes are calculated as Control over Fgf20. The function relevel achieves this:

```{r warning=FALSE,echo=TRUE,message=FALSE,eval=TRUE}

dermis$condition <- relevel(dermis$condition,"Ctrl")

### Running DESeq
  data_DESeq <- DESeq(dermis)
### Building the result table
  
  p_adjusted <- 0.1
  res <- results(data_DESeq,alpha = p_adjusted,contrast = c("condition","Ctrl","Fgf20"))
  res
 
```

As res is a DataFrame object, it carries metadata with information on the meaning of the columns:

```{r}
mcols(res, use.names=TRUE)
```


The first column, `baseMean`, is a just the average of the normalized count values, dividing by size factors, taken over all samples. The remaining four columns refer to a specific contrast, namely the comparison of the ``Ctrl` level over the `Fgf20` level for the factor variable `condition`. See the help page for results (by typing `?results`) for information on how to obtain other contrasts.

The column log2FoldChange is the effect size estimate. It tells us how much the gene's expression seems to have changed due to treatment with Fgf20 in comparison to controlled samples. This value is reported on a logarithmic scale to base 2: for example, a log2 fold change of 1.5 means that the gene's expression is increased by a multiplicative factor of 21.5 or approximately 2.82.

Of course, this estimate has an uncertainty associated with it, which is available in the column `lfcSE`, the standard error estimate for the log2 fold change estimate. We can also express the uncertainty of a particular effect size estimate as the result of a statistical test. The purpose of a test for differential expression is to test whether the data provides sufficient evidence to conclude that this value is really different from zero. DESeq2 performs for each gene a hypothesis test to see whether evidence is sufficient to decide against the null hypothesis that there is no effect of the treatment on the gene and that the observed difference between treatment and control was merely caused by experimental variability (i.e., the type of variability that you can just as well expect between different samples in the same treatment group). As usual in statistics, the result of this test is reported as a __p__ value, and it is found in the column `pvalue`. (Remember that a p value indicates the probability that a fold change as strong as the observed one, or even stronger, would be seen under the situation described by the null hypothesis.)

We can also summarize the results with the following line of code, which reports some additional information, which will be covered in later sections.

```{r}
summary(res)
```


Note that there are many genes with differential expression due to  treatment at the FDR level of 10%.  However, there are two ways to be more strict about which set of genes are considered significant:

*   lower the false discovery rate threshold (the threshold on `padj` in the results table)
*   raise the log2 fold change threshold from 0 using the `lfcThreshold` argument of results. See the `DESeq2` vignette for a demonstration of the use of this argument.

If we lower the false discovery rate threshold, we should also tell this value to `results()`, so that the function will use an alternative threshold for the optimal independent filtering step:

We subset the results table to these genes and then sort it by the log2 fold change .

```{r}
  resSig <- subset(res, padj < p_adjusted)
  resSig <- as.data.frame(resSig)
  
  ### Annotated the genes with previously downloaded data
  resSig$ensembl_gene_id <- rownames(resSig)
  resSig_dermis_annotated <- merge(resSig,gene_attribute_data,by="ensembl_gene_id")
  resSig_dermis_annotated <- resSig_dermis_annotated[ order( 
                              -abs(resSig_dermis_annotated$log2FoldChange )),]
```

#### List of differentially expressed genes
 Rounding of the long decimal values.

```{r warning=FALSE,echo=TRUE,message=FALSE}
resSig_dermis_annotated[,c(-1,-8,-9)] <-round(resSig_dermis_annotated[,c(-1,-8,-9)],4)
## DT::datatable(resSig_dermis_annotated[,c(1:3,6:9)],rownames = FALSE)
resSig_dermis_annotated[,c(1:3,6:9)]
```

### Diagnostic plots

A quick way to visualize the counts for a particular gene is to use the plotCounts function, which takes as arguments the DESeqDataSet, a gene name, and the group over which to plot the counts.

```{r}
topGene <- rownames(res)[which.min(res$padj)]
plotCounts(ddsHTSeq, gene=topGene, intgroup=c("condition"))
```

The finishing part of this tutorial has been made following resource "Lab: End-to-end RNA-Seq workflow, Mike Love, Simon Anders, Wolfgang Huber" from bioconductor

The above plot is not complete , there are other efficient ways to visualize . 



#### DIY : Practice

There is a new workflow by `Michael I. Love`, the developer of DESeq2. It has much more detailed explanations and diagonistic plots. Students are highly encouraged to go through this new [workflow](http://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#can-i-use-deseq2-to-analyze-paired-samples) 

